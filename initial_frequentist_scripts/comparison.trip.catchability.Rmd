---
title: "comparison.trip.catchability"
output: html_document
date: "2024-03-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, wdnr.fmdb, wdnr.gis, lubridate, here, lme4, glmmTMB, DHARMa, emmeans, effects, AUC)

```

Now comparing statistical modeling outcomes for trip-level angling cpue vs. population density (from PEs) or relative abundance (electrofishing cpe)

```{r}
# walleye data

cpue.pe.wye<-read_csv(here::here("data","indiv.level.cpue.pe.walleye.csv"))%>%
  mutate(ln.pop.density=log(pop.density))%>%
  ungroup()%>%
  mutate(sample.date=ymd(sample.date),
         month=month(sample.date))%>%
  filter(!is.na(pop.density)&!is.na(cpue))%>%
  filter(cpue<20)

ef.cpe.wye<-read_csv(here::here("data","dnr.ef.cpe.walleye.lmb.csv"))%>%
filter(species=="walleye" & gear=="boom_shocker")%>%
  mutate(km.shocked=total_effort*1.61,
         cpe_km=total_catch/km.shocked)%>%
  filter(km.shocked>1)%>%
  group_by(wbic, year)%>%
  summarize(mean_cpe_km=mean(cpe_km),
            sd_cpe_km=sd(cpe_km),
            n_ef_surveys=n())%>%
  ungroup()

# join by year and wbic to walleye cpue

cpue.ef.cpe.wye<-cpue.pe.wye%>%
  dplyr::select(county:shore.length)%>%
  left_join(ef.cpe.wye, by=c("wbic","year"))%>%
  filter(!is.na(mean_cpe_km) & !is.na(cpue))%>%
  mutate(ln.ef.cpe=log(mean_cpe_km))%>%
  filter(cpue<20)%>%
  mutate(month=as.factor(month(sample.date)))
  

# lmb data
cpue.ef.cpe.lmb<-read_csv(here::here("data","indiv.level.cpue.ef.cpe.lmb.csv"))%>%
  dplyr::select(county:shore.length)%>%
  filter(!is.na(mean_cpe_km) & !is.na(cpue))%>%
  mutate(ln.ef.cpe=log(mean_cpe_km))%>%
  filter(cpue<20)%>%
  mutate(month=as.factor(month(sample.date)))
```
Starting with walleye pe data: cpue.pe.wye

```{r}
ggplot(cpue.pe.wye)+
  geom_point(aes(x=pop.density, y=cpue))+
  theme_bw()


ggplot(cpue.pe.wye)+
  geom_point(aes(x=ln.pop.density, y=log(cpue+0.01)))+
  theme_bw()
```

used month instead of day of year--more range in  season with this dataset
```{r}
mod.null.wye.pe<-glmmTMB(cpue~ln.pop.density + month, 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + month)

mod.wbic.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|wbic) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + month+(1|wbic))

mod.year.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|year) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + month+(1|year))

mod.date.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + month+(1|sample.date))



mod.wbic.year.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|wbic)+(1|year) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + month+(1|wbic)+(1|year))

mod.wbic.date.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density +
                 month+(1|wbic)+(1|sample.date))

mod.year.date.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|year)+(1|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density +
                 month+(1|year)+(1|sample.date))

mod.wbic.year.date.wye.pe<-glmmTMB(cpue~ln.pop.density + month+(1|wbic)+(1|year)+(county|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density +
                 month+(1|wbic)+(1|year)+(1|sample.date))

# added county effect to mod.wbic.year.date.wye.pe. Added mod.wye.pe to take original's place (without county random slope)
AIC(mod.null.wye.pe, mod.wbic.wye.pe, mod.year.wye.pe, mod.date.wye.pe, mod.wbic.year.wye.pe, mod.wbic.date.wye.pe, mod.year.date.wye.pe, mod.wbic.year.date.wye.pe, mod.wye.pe)

sim.resid<-simulateResiduals(mod.wbic.year.date.wye.pe)
plot(sim.resid)

mod.wye.pe<-mod.wbic.year.day.wye.pe
```
```{r}
summary(mod.wye.pe)
performance::r2(mod.wye.pe)
```
woof, incredibly low r2

Does the same thing happen if I sample out a similar sample size from the summer? 

```{r}
# filter to 2018 and 2019, which has  35 unique lakes and 3816 observations. Need to stick with dates that have multiple observations


dateObs<-cpue.pe.wye.f%>%
  group_by(sample.date)%>%
  summarize(n=n())%>%
  filter(n>10)

cpue.pe.wye.f<-filter(cpue.pe.wye, year%in%c(2018, 2019) & sample.date%in%dateObs$sample.date)

pull.dates<-sample(dateObs$sample.date, 46)

# rather than selecting by wbic, let's sample by sample.date to ensure we can fit the random effect
# selecting 46 random dates to correspond with fishscapes data

# nObs<-cpue.pe.wye.f%>%
#   group_by(wbic)%>%
#   summarize(nObs=n())%>%
#   ungroup()%>%
#   filter(nObs>20)
# 
# 
# # then r andomly select 13 lakes
# wbic.unique<-unique(nObs$wbic)
# wbic.13<-sample(wbic.unique, size=13, replace=F)
# wbic.13

# fishscapes data has between 9 and 27 observations at each lake. Let's select 19 from each lake
cpue.pe.wye.sample<-cpue.pe.wye.f%>%
  mutate(year=as.factor(year))%>%
  filter(sample.date%in%pull.dates)%>%
    slice_sample(n=250)%>%
  mutate(year=as.factor(year),
         doy=yday(sample.date),
         doy2=doy^2,
         sc.doy=scale(doy),
         sc.doy2=scale(doy2))
# close enough; more lakes than fishscapes (45) but enough repeated date samples, hopefully

sub.mod<-glmmTMB(cpue~ln.pop.density + year+(1|wbic)+(county|sample.date) , 
                  data=cpue.pe.wye.sample, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density +
                 sc.doy+sc.doy2+year+(1|wbic)+(1|sample.date))
sim.resid<-simulateResiduals(sub.mod)
plot(sim.resid)

performance::r2(sub.mod)
```
```{r}
summary(sub.mod)
```
Just in case, break it up into zi and conditional to get r2

```{r}


sub.mod.zi<-glmmTMB(cpue~1 , 
                  data=cpue.pe.wye.sample, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density +
                 sc.doy+sc.doy2+year+(1|wbic)+(1|sample.date))
# convergence problem--ignoring zi model

cpue.pe.wye.sample.no.0<-filter(cpue.pe.wye.sample, cpue>0)

sub.mod.cond<-glmmTMB(cpue~ln.pop.density + year+(1|wbic)+(1|sample.date) , 
                  data=cpue.pe.wye.sample.no.0, family=glmmTMB::lognormal(link="log"))
performance::r2(sub.mod.cond)

```



```{r}
cpue.pe.wye$mod.pred<-predict(mod.wye.pe, type="response")

ggplot(cpue.pe.wye)+
  geom_point(aes(x=pop.density, y=cpue))+
  geom_point(aes(x=pop.density, y=mod.pred), color="red")+
  theme_bw()
```
now walleye ef cpe

```{r}
ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  theme_bw()


ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=ln.ef.cpe, y=log(cpue+0.01)))+
  theme_bw()
```


```{r}
mod.null.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month, 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month)

mod.wbic.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic))

mod.wbic.year.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic)+(1|year))

mod.wbic.day.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|sample.date))

mod.wbic.year.day.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year)+(1|sample.date) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|year)+(1|sample.date))

AIC(mod.null.wye.ef.cpe, mod.wbic.wye.ef.cpe, mod.wbic.year.wye.ef.cpe, mod.wbic.day.wye.ef.cpe, mod.wbic.year.day.wye.ef.cpe)

sim.resid<-simulateResiduals(mod.wbic.year.day.wye.ef.cpe)
plot(sim.resid)

mod.wye.ef.cpe<-mod.wbic.year.day.wye.ef.cpe
```
```{r}
summary(mod.wye.ef.cpe)
performance::r2(mod.wye.ef.cpe)
```
low r2, but actually higher than the model fit to PEs

```{r}
cpue.ef.cpe.wye$mod.pred<-predict(mod.wye.ef.cpe, type="response")

ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  geom_point(aes(x=mean_cpe_km, y=mod.pred), color="red")+
  theme_bw()
```


And LMB ef cpe


```{r}
ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  theme_bw()


ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=ln.ef.cpe, y=log(cpue+0.01)))+
  theme_bw()
```
Visually, there's already less of a distinct pattern compared to walleye

Convergence issues if I fit the model with month as a covariate. Looking at a histogram of months in the data, I may see the problem: 

```{r}
hist(as.numeric(cpue.ef.cpe.lmb$month))
```
I'm going to adjust the month predictor; 5, 6, 7, 8, 9, 10 will remain as dummy variables; 1, 2, 3, 4, 11, and 12 will be baseline

```{r}
cpue.ef.cpe.lmb$month<-ifelse(cpue.ef.cpe.lmb$month%in%c(1,2,3,4,11,12), 0, cpue.ef.cpe.lmb$month)
hist(cpue.ef.cpe.lmb$month)

cpue.ef.cpe.lmb$month<-as.factor(cpue.ef.cpe.lmb$month)
str(cpue.ef.cpe.lmb$month)
```


```{r}
mod.null.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month, 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month)

mod.wbic.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic))

mod.wbic.year.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic)+(1|year))

mod.wbic.day.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|sample.date))

mod.wbic.year.day.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year)+(1|sample.date) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|year)+(1|sample.date))

AIC(mod.null.lmb.ef.cpe, mod.wbic.lmb.ef.cpe, mod.wbic.year.lmb.ef.cpe, mod.wbic.day.lmb.ef.cpe, mod.wbic.year.day.lmb.ef.cpe)

sim.resid<-simulateResiduals(mod.wbic.year.day.lmb.ef.cpe)
plot(sim.resid)

mod.lmb.ef.cpe<-mod.wbic.year.day.lmb.ef.cpe
```
```{r}
summary(mod.lmb.ef.cpe)
performance::r2(mod.lmb.ef.cpe)
```
low, but like ef.cpue.wye, not as low as model using PEs

```{r}
cpue.ef.cpe.lmb$mod.pred<-predict(mod.lmb.ef.cpe, type="response")

ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  geom_point(aes(x=mean_cpe_km, y=mod.pred), color="red")+
  theme_bw()
```

For final comparison, fishscapes data, cpue vs PE and cpue vs ef cpe


```{r}
fishscapes.pe<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))%>%
  filter(!is.na(pop.density))

fishscapes.ef.cpe<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))%>%
  filter(!is.na(efCPE))

fishscapes.full<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))

all_equal(fishscapes.pe, fishscapes.ef.cpe)
# good; just need the one


fishscapes<-fishscapes.pe%>%
  mutate(cpue=anCPUE,
         ln.cpue=log(cpue+0.01),
         month=month(date))%>%
  rename("wbic"=WBIC,
         "ef.cpe"=efCPE)%>%
  mutate(wbic=as.factor(wbic),
         year=as.factor(year),
         month=as.factor(month))
  

ggplot(fishscapes)+
  geom_point(aes(x=pop.density, y=cpue))+
  theme_bw()


ggplot(fishscapes)+
  geom_point(aes(x=ln.pop.density, y=ln.cpue))

hist(as.numeric(fishscapes$month))
```

Fewer months than dnr data; could still use month or day of year

instead of date random effect and month as a fixed effect, adding day of year as quadratic fixed effect.
date will still be tested as a random effect in some models

previous convergence problems (and mismatch with previous models) was caused by year being numeric instead of a factor. silly goose.

```{r}

mod.null.lmb.pe<-glmmTMB(cpue~ln.pop.density + year, 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year)


mod.lakeID.lmb.pe<-glmmTMB(cpue~ln.pop.density + year +(1|lakeID) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|lakeID))



mod.caughtBy.lmb.pe<-glmmTMB(cpue~ln.pop.density + year +(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb.pe<-glmmTMB(cpue~ln.pop.density +  year +(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb.pe<-glmmTMB(cpue~ln.pop.density + year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb.pe<-glmmTMB(cpue~ln.pop.density + year+(1|lakeID)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb.pe<-glmmTMB(cpue~ln.pop.density +year+(1|caughtBy)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))

mod.lakeID.caughtBy.date.lmb.pe<-glmmTMB(cpue~ln.pop.density +year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2+year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb.pe, mod.lakeID.lmb.pe, mod.caughtBy.lmb.pe, mod.date.lmb.pe, mod.lakeID.caughtBy.lmb.pe, mod.lakeID.date.lmb.pe, mod.caughtBy.date.lmb.pe, mod.lakeID.caughtBy.date.lmb.pe )

sim.resid<-simulateResiduals(mod.caughtBy.date.lmb.pe)
plot(sim.resid)

mod.fs.pe<-mod.caughtBy.date.lmb.pe
```

Interesting; caughtBy and date random effects are best fits; does not include wbic!

```{r}
summary(mod.fs.pe)
performance::r2(mod.fs.pe)
performance::r2_zeroinflated(mod.fs.pe)
```
higher, but not incredible r2. 

Closer look at variance explained

```{r}
# full model
sd.response<-sd(fishscapes$cpue)
var.response<-sd.response^2

predictions<-predict(mod.fs.pe, type="response")
sd.pred<-sd(predictions)
var.pred<-sd.pred^2

# null model
# I'm calling model with only fixed effects the null model here
mod.null.lmb.pe<-glmmTMB(cpue~ln.pop.density + year, 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year)

predictions.null<-predict(mod.null.lmb.pe)
var.pred.null<-var(predictions.null)

predictions.date.only<-predict(mod.date.lmb.pe)
var.pred.date.only<-var(predictions.date.only)

predictions.caughtBy.only<-predict(mod.caughtBy.lmb.pe)
var.pred.caughtBy.only<-var(predictions.caughtBy.only)
```

look specifically at binomial model and lognormal random effects separately--i think the combined hurdle model r2 outputs are obscuring stuff

```{r}
mod.caughtBy.date.lmb.pe.zi<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))
summary(mod.caughtBy.date.lmb.pe.zi)

performance::r2_zeroinflated(mod.caughtBy.date.lmb.pe.zi)

mod.caughtBy.date.lmb.pe.zi.fixed<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year)
performance::r2_zeroinflated(mod.caughtBy.date.lmb.pe.zi.fixed)

mod.caughtBy.date.lmb.pe.zi.angler<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|caughtBy))
performance::r2_zeroinflated(mod.caughtBy.date.lmb.pe.zi.angler)

mod.caughtBy.date.lmb.pe.zi.date<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|date))
performance::r2_zeroinflated(mod.caughtBy.date.lmb.pe.zi.date)


```
Now the same but without fixed effects

```{r}
mod.zi.full<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year + (1|caughtBy) + (1|date))
performance::r2_zeroinflated(mod.zi.full)

mod.zi.fixed.only<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year)
performance::r2_zeroinflated(mod.zi.fixed.only)

mod.zi.random.only<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~1+(1|caughtBy) + (1|date))
performance::r2_zeroinflated(mod.zi.random.only)

mod.zi.caughtBy.only<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~1+(1|caughtBy) )
performance::r2_zeroinflated(mod.zi.caughtBy.only)

mod.zi.date.only<-glmmTMB(cpue~1 , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~1+ (1|date))
performance::r2_zeroinflated(mod.zi.date.only)


```



r2 for zero model only is 0.18

```{r}
fishscapes.no.0<-filter(fishscapes, cpue!=0)

mod.caughtBy.date.lmb.pe.conditional<-glmmTMB(cpue~ln.pop.density +year+(1|caughtBy)+(1|date) , 
                  data=fishscapes.no.0, family=glmmTMB::lognormal(link="log"))
summary(mod.caughtBy.date.lmb.pe.conditional)
performance::r2(mod.caughtBy.date.lmb.pe.conditional)

```
```{r}
mod.caughtBy.date.lmb.pe.conditional.null<-glmmTMB(cpue~ln.pop.density +year, 
                  data=fishscapes.no.0, family=glmmTMB::lognormal(link="log"))
summary(mod.caughtBy.date.lmb.pe.conditional.null)
performance::r2(mod.caughtBy.date.lmb.pe.conditional.null)

```
```{r}
mod.caughtBy.date.lmb.pe.conditional.caughtBy<-glmmTMB(cpue~ln.pop.density +year+(1|caughtBy), 
                  data=fishscapes.no.0, family=glmmTMB::lognormal(link="log"))
summary(mod.caughtBy.date.lmb.pe.conditional.caughtBy)
performance::r2(mod.caughtBy.date.lmb.pe.conditional.caughtBy)

```
```{r}
mod.caughtBy.date.lmb.pe.conditional.date<-glmmTMB(cpue~ln.pop.density +year+(1|date), 
                  data=fishscapes.no.0, family=glmmTMB::lognormal(link="log"))
summary(mod.caughtBy.date.lmb.pe.conditional.date)
performance::r2(mod.caughtBy.date.lmb.pe.conditional.date)

```

```{r}
mod.fs.pe<-glmmTMB(cpue~ln.pop.density +year+(1|caughtBy)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))
mod.fs.pe.date<-glmmTMB(cpue~ln.pop.density +year+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|date))

```

```{r}
fishscapes$mod.pred<-predict(mod.fs.pe, type="response")
fishscapes$mod.pred.noCaughtBy<-predict(mod.fs.pe.date, type="response")

ggplot(fishscapes)+
  geom_point(aes(x=pop.density, y=cpue))+
  geom_point(aes(x=pop.density, y=mod.pred), color="red")+
 # geom_point(aes(x=pop.density, y=mod.pred.noCaughtBy), color="blue")+
  theme_bw()
```


Now look closer at values of random intercepts

```{r}
random<-ranef(mod.fs.pe)
zi.random<-random$zi
cond.random<-random$cond

zi.day.effect<-zi.random$date
zi.day.effect$date<-rownames(zi.day.effect)
zi.day.effect$intercept<-exp(zi.day.effect$`(Intercept)`)/(1+exp(zi.day.effect$`(Intercept)`))

ggplot(zi.day.effect)+
  geom_point(aes(x=date, y=intercept))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=90))
ggsave(here::here("figures","fishscapes","zi.date.effect.png"), height=4, width=6)


zi.angler.effect<-zi.random$caughtBy
zi.angler.effect$caughtBy<-rownames(zi.angler.effect)
zi.angler.effect$intercept<-exp(zi.angler.effect$`(Intercept)`)/(1+exp(zi.angler.effect$`(Intercept)`))

ggplot(zi.angler.effect)+
  geom_point(aes(x=caughtBy, y=intercept))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=90))
ggsave(here::here("figures","fishscapes","zi.angler.effect.png"), height=4, width=6)

```

```{r}
cond.day.effect<-cond.random$date
cond.day.effect$date<-rownames(cond.day.effect)
cond.day.effect$intercept<-cond.day.effect$`(Intercept)`

ggplot(cond.day.effect)+
  geom_point(aes(x=date, y=exp(intercept)))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=90))
ggsave(here::here("figures","fishscapes","cond.date.effect.png"), height=4, width=6)


cond.angler.effect<-cond.random$caughtBy
cond.angler.effect$caughtBy<-rownames(cond.angler.effect)
cond.angler.effect$intercept<-cond.angler.effect$`(Intercept)`

ggplot(cond.angler.effect)+
  geom_point(aes(x=caughtBy, y=exp(intercept)))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=90))
ggsave(here::here("figures","fishscapes","cond.angler.effect.png"), height=4, width=6)

```


Repeat, but with ef cpe

```{r}
ggplot(fishscapes)+
  geom_point(aes(x=ef.cpe, y=cpue))+
  theme_bw()


ggplot(fishscapes)+
  geom_point(aes(x=ln.ef.cpe, y=ln.cpue))

```

Fewer months than dnr data; could still use month or day of year

instead of date random effect and month as a fixed effect, adding day of year as quadratic fixed effect.
date will still be tested as a random effect in some models

Moving sc.doy out of conditional model, but keeping it in zero inflated model. (problems with convergence, consistently no effect in conditional model)
```{r}

mod.null.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe  + year, 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year)

mod.lakeID.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year +(1|lakeID) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID))
# convergence problem
mod.caughtBy.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +  year +(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +  year +(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +year+(1|lakeID)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +year+(1|caughtBy)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))


mod.lakeID.caughtBy.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb.ef.cpe, mod.lakeID.lmb.ef.cpe, mod.caughtBy.lmb.ef.cpe, mod.date.lmb.ef.cpe, mod.lakeID.caughtBy.lmb.ef.cpe, mod.lakeID.date.lmb.ef.cpe, mod.caughtBy.date.lmb.ef.cpe, mod.lakeID.caughtBy.date.lmb.ef.cpe )

sim.resid<-simulateResiduals(mod.lakeID.caughtBy.date.lmb.ef.cpe)
plot(sim.resid)

mod.fs.ef.cpe<-mod.lakeID.caughtBy.date.lmb.ef.cpe
```


```{r}
summary(mod.fs.ef.cpe)
performance::r2(mod.fs.ef.cpe)

performance::r2_zeroinflated(mod.fs.ef.cpe)
```
ef.cpe not a significant predictor. (replaced by wbic?)

looking at predictions (deterministic--no error term) for catch rates. have to model separately zero and non-zero
```{r}
fishscapes$mod.pred<-predict(mod.fs.ef.cpe, type="response")

fishscapes$zero.pred<-predict(mod.fs.ef.cpe, type="zprob")
fishscapes$probCatchFish<-1-fishscapes$zero.pred

fishscapes$caughtFishSim<-rep(NA)


for(i in 1:nrow(fishscapes)){
fishscapes$caughtFishSim[i]<-sample(c(0,1), 1, prob=c(fishscapes$zero.pred[i], fishscapes$probCatchFish[i]))
}

fs.zeros<-filter(fishscapes, caughtFishSim==0)
fs.ones<-filter(fishscapes, caughtFishSim==1)

fs.ones$pred.cpue<-predict(mod.fs.ef.cpe, newdata=fs.ones, type="response")
fs.zeros$pred.cpue<-rep(0)

fs.pred<-rbind.data.frame(fs.ones, fs.zeros)


ggplot(fs.pred)+
  geom_point(aes(x=ef.cpe, y=cpue))+
  geom_point(aes(x=ef.cpe, y=pred.cpue), color="red", alpha=0.5)+
  theme_bw()

ggplot(fs.pred)+
  geom_histogram(aes(cpue), color="gray")+
  geom_histogram(aes(pred.cpue), fill="red", alpha=0.5)

ggplot(fs.pred)+
  geom_point(aes(x=cpue, y=pred.cpue))+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  theme_bw()
```

left off here: for(i in 1:nrow(fishscapes)){
fishscapes$caughtFish[i]<-sample(c(0,1), 1, prob=c(fishscapes$zero.pred[i], fishscapes$probCatchFish[i]))
}
Looking at random effects: 
lakeID has basically no effect on zero probability
```{r}
rand.cpue<-ranef(mod.fs.ef.cpe, condVar=T)
rand.zero<-ranef(mod.fs.ef.cpe, condVar=T)

hist(rand.zero$zi$date$`(Intercept)`)
# is there a pattern in date effect?

dates.zero<-rand.zero$zi$date
dates.zero$date<-ymd(rownames(dates.zero))

dates.zero$doy<-yday(dates.zero$date)
dates.zero$year<-year(dates.zero$date)

ggplot(dates.zero)+
  geom_point(aes(x=doy, y=`(Intercept)`, color=as.factor(year)))+
  theme_bw()

caught
```
No, not really. This suggests to me that there could have been differences in weather, temperature, etc influencing catchability each day. Those last few days are around zero, maybe because there was less variation in other variables at the end of the 2019 season. (less overlap of anglers, none of dates, potentially none of lakes)



More stuff interrogating model: predictions and r2 without angler id, full fishscapes dataset without population estimates or electrofishign cpe (didn't work well--residuals were crazy. Even if it doesn't have a significant effect, having some metric of fish population is important)
--------------------------------------------------------------------------------
Look at the next best fitting model that does not include angler effects

```{r}
summary(mod.date.lmb.ef.cpe)
performance::r2(mod.date.lmb.ef.cpe)
```
```{r}
fishscapes.ef.cpe$pred.date<-predict(mod.date.lmb.ef.cpe, type="response")
ggplot(fishscapes.ef.cpe)+
  geom_point(aes(x=ln.ef.cpe, y=anCPUE))+
  geom_point(aes(x=ln.ef.cpe, y=pred.date), color="red")
```









What if I fit the full dataset, avoiding population density entirely? 

one lake doesn't have a WBIC, so using lakeID instead

```{r}
fishscapes.full<-fishscapes.full%>%
  mutate(year=as.factor(year),
         cpue=anCPUE,
         wbic=as.factor(WBIC),
         lakeID=as.factor(lakeID),
         date=as.factor(date))
  

mod.null.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2 + year, 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year)

mod.lakeID.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|lakeID) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID))

mod.caughtBy.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|caughtBy)+(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))
mod.lakeID.caughtBy.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb, mod.lakeID.lmb, mod.caughtBy.lmb, mod.date.lmb, mod.lakeID.caughtBy.lmb, mod.lakeID.date.lmb, mod.caughtBy.date.lmb, mod.lakeID.caughtBy.date.lmb )


mod.fs.full<-mod.lakeID.caughtBy.date.lmb

mod.resid<-simulateResiduals(mod.fs.full, plot=T)
plot(mod.resid, form=fishscapes.full$sc.doy)
plot(mod.resid, form=fishscapes.full$sc.doy2)
plot(mod.resid, form=fishscapes.full$year)
plot(mod.resid, form=fishscapes.full$lakeID)
plot(mod.resid, form=fishscapes.full$date)
plot(mod.resid, form=fishscapes.full$caughtBy)

```

```{r}
summary(mod.fs.full)
performance::r2(mod.fs.full)
```










only random effects

```{r}
mod.random<-glmmTMB(cpue~(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~(1|lakeID)+(1|date)+(1|caughtBy) )

simulateResiduals(mod.random, plot=T)
```
some metric of fish abundance is probably necessary. without it, I get these super weird residuals


fishscapes full

```{r}
caught.prop<-fishscapes.full%>%
  mutate(totalFish=sum(nCaught))%>%
  group_by(caughtBy)%>%
  summarize(nFish=sum(nCaught),
            totalFish=unique(totalFish))%>%
  ungroup()%>%
  mutate(propCatch=nFish/totalFish,
         propAnglers=1/length(unique(fishscapes.full$caughtBy)))%>%
  arrange(propCatch)%>%
  mutate(cumPropCatch=cumsum(propCatch),
         cumPropAnglers=cumsum(propAnglers))

order<-caught.prop$caughtBy

caught.prop$caughtBy<-factor(caught.prop$caughtBy, levels=order)

ggplot(caught.prop)+
  geom_bar(aes(x=caughtBy, y=propCatch), stat="identity")
```

Lorenz plot

```{r}
ggplot(caught.prop)+
  geom_line(aes(x=cumPropAnglers, y=cumPropCatch))+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  geom_abline(slope=-1, intercept=1, linetype="dashed")+
  theme_bw()
```

Neat, but not accounting for differences in effort. Do that one comparing between trip and between angler inequaliity

then look at differences in fish size--associated with catching power intercept? 

catch power as a random walk?

Between angler inequality: cumulative proportion of catch by cumulative proportion of effort for each angler's contribution to the season total

Between trip inequality: cumulative proportion of catch by the cumulative proportion of effort that each trip contributes to the season total

```{r}
between.angler<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort))%>%
  group_by(caughtBy)%>%
  summarize(angler.fish=sum(nCaught),
            angler.effort=sum(effort),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=angler.fish/fish.total,
         prop.effort=angler.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))%>%
  mutate(overall.cpue=angler.fish/angler.effort)
  

#  I think this comparison might be misleading--aggregates of anglers vs. individual trips. Aggregate trips by sample id instead
between.trip<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort),
         trip=paste(sampleID, angler_num, sep="_"),
         trip.fish=nCaught,
         trip.effort=effort,
         prop.fish=trip.fish/fish.total,
         prop.effort=trip.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))

between.lake<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort))%>%
  group_by(lakeID)%>%
  summarize(lake.fish=sum(nCaught),
            lake.effort=sum(effort),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=lake.fish/fish.total,
         prop.effort=lake.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))


ggplot()+
  geom_line(data=between.angler, aes(y=cum.prop.fish, x=cum.prop.effort), color="blue")+
  geom_line(data=between.trip, aes(y=cum.prop.fish, x=cum.prop.effort), color="red")+
  geom_line(data=between.lake, aes(y=cum.prop.fish, x=cum.prop.effort), color="green")+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  theme_bw()
```

Much more inequality among trips than among anglers, but not comparing same 'sample size'--way more trip dates than unique anglers

This is not unexpected, "there is inequality within, and overlap between, the trip-to-trip success of each angler" Lambert and Aronson 1993; Yao 1999

other catch inequality papers: Mosindy and Duffy 2007 (musky), Van Poorten and Post 2005 (rainbow trout)


can I compare to angler diary data? Opportunity to show changes in Gini coefficient over time if I can have access to more years. Split by species

```{r}
codes<-read_csv(here::here("data","coding.csv"))%>%
  dplyr::select(code, `Target Species`, category)%>%
  rename("TargetSpecies"=code,
         "TargetSpeciesName"=`Target Species`, 
         "TargetSpeciesCat"=category)
`%!in%`<-Negate(`%in%`)

diary<-read_csv(here::here("data","angler.diary.data.csv"))%>%
    arrange(SurveyID)%>%
  mutate(daysMonth=ifelse(Month%in%c(9,4,6,11), 30, 
                          ifelse(Month==2, 28, 31)),
         date_month=as.numeric(month(mdy(Date))),
         outsideMonth=ifelse(FishedYN==1 & date_month!=Month,1,0),
         Year=ifelse(Month%in%c(4,5,6,7,8,9,10,11,12), 2021, 2022))%>%
  # remove entries where participants went fishing outside the sampled calendar month
  filter(outsideMonth==0)%>%
  filter(Mode==1)%>%
  filter(SurveyID!="999999")%>%
  filter(SurveyID%!in%c(1:10))%>%
  left_join(codes, by="TargetSpecies")%>%
  filter(County!="99")

# Do I care if they're representative? I don't think so, but worth checking to see if it changes the results to leave out emailed responses
fished<-diary%>%
  filter(FishedYN==1)

# let's pivot thisl onger to make it easier to work with

fished.long.caught<-fished%>%
  dplyr::select(SurveyID, Date, Month, Year, WaterFished, County, Hours, TargetSpeciesName, ends_with("Caught"))%>%
  pivot_longer(cols=c(BluegillNumCaught:OtherNumCaught), names_to="species",values_to="numCaught")%>%
  mutate(species=str_replace(species, "NumCaught", ""),
         cpue=numCaught/Hours)%>%
  filter(TargetSpeciesName%in%c("Walleye","Bluegill / Sunfish","Largemouth Bass") &
           species%in%c("Walleye","Bluegill","LGBass"))%>%
  filter(!is.na(numCaught))%>%
  mutate(TargetSpeciesName=ifelse(TargetSpeciesName=="Bluegill / Sunfish", "Bluegill",
                                  ifelse(TargetSpeciesName=="Largemouth Bass", "LGBass", TargetSpeciesName)))%>%
  filter(TargetSpeciesName==species)

# lorenz plot--just LMB for now, and only angler targeting them

between.angler.diary<-fished.long.caught%>%
  #filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  group_by(species)%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours))%>%
  ungroup()%>%
  rename("ID"=SurveyID)%>%
  group_by(ID, species)%>%
  summarize(nFish=sum(numCaught),
            nHours=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=nFish/fish.total,
         prop.effort=nHours/effort.total)%>%
  group_by(species)%>%
  arrange(prop.fish, .by_group=T)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))%>%
  ungroup()%>%
  mutate(type="between_anglers")


between.trip.diary<-fished.long.caught%>%
  #filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  group_by(species)%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours))%>%
  ungroup()%>%
  mutate(ID=paste(SurveyID, Date, WaterFished, sep="_"))%>%
  group_by(ID, species)%>%
  summarize(nFish=sum(numCaught),
            nHours=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=nFish/fish.total,
         prop.effort=nHours/effort.total)%>%
  group_by(species)%>%
  arrange(prop.fish, .by_group=T)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))%>%
  ungroup()%>%
  mutate(type="between.trips")

# imperfect; includes duplicate lakes/rivers within counties
between.water.diary<-fished.long.caught%>%
  #filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  group_by(species)%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours))%>%
  ungroup()%>%
  mutate(ID=paste(County, WaterFished, sep="_"))%>%
  group_by(ID, species)%>%
  summarize(nFish=sum(numCaught),
            nHours=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=nFish/fish.total,
         prop.effort=nHours/effort.total)%>%
  group_by(species)%>%
  arrange(prop.fish, .by_group=T)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))%>%
  ungroup()%>%
  mutate(type="between.waters")

all.plot<-rbind.data.frame(between.angler.diary, between.trip.diary, between.water.diary)


ggplot(all.plot)+
  geom_line(aes(x=cum.prop.effort, y=cum.prop.fish, color=type))+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  facet_grid(.~species)+
  theme_bw()
ggsave(here::here("figures","lorenz.angler.diaries.2021.png"), height=4, width=10)
```

Next step:
- filter to lakes with biological survey data--fit catch curve with random effects? See how much data is actually left. 
- add musky for giggles?
```{r}
dnr.surveys<-get_fmdb_surveys(year=c(2021))%>%
  mutate(waterbody_county=paste(waterbody.name, county, sep="_"),
         waterbody_county=tolower(waterbody_county))

diary.comp<-diary%>%
  filter(WaterFished!="99")%>%
  mutate(waterbodyName=str_replace_all(WaterFished, " ", "_"),
         waterbody_county=paste(waterbodyName, County, sep="_"),
         waterbody_county=tolower(waterbody_county))%>%
  filter(waterbody_county%in%dnr.surveys$waterbody_county)

dnr.comp<-dnr.surveys%>%
  filter(waterbody_county%in%diary.comp$waterbody_county)%>%
  filter(primary.survey.purpose%in%c("fisheries_assessments_lakes_early_spring_wae_mue",
                                     "fisheries_assessments_lakes_late_spring_bass_pan"))

diary.surveys<-diary.comp%>%
  filter(waterbody_county%in%dnr.comp$waterbody_county)
  

# how many repeated trips did we get?

repeats<-diary.surveys%>%
  group_by(SurveyID)%>%
  summarize(n=n())

View(diary.surveys%>%
  group_by(Date)%>%
  summarize(n=n()))

# hey! that's not too bad!

# by target species?

diary.targets<-diary.surveys%>%
  group_by(TargetSpeciesName)%>%
  summarize(n=n())
# a little over 200 entries for walleye as a target

diary.wae<-diary.surveys%>%
  filter(TargetSpeciesName=="Walleye")%>%
  mutate(cpue=WalleyeNumCaught/Hours)%>%
  left_join()

ggplot(diary.targets)+
  geom_point(aes(x=))
```


fit catch curve

```{r}
# set up data
# do model selection
diary.mod.null<-
# poke random effects
```

