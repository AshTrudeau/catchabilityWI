---
title: "bayesian pop est"
output: html_document
date: "2024-04-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, here, lubridate, lme4, rstan, shinystan, RSQLite, MFEUtilities)

```

Can I produce PEs for fishscapes lakes using Bayesian methods?

```{r}
wd<-getwd()
db.dir<-paste0(wd, "/MFEdb/")
db<-"MFEdb_20220405.db"

dbTableList(db.dir, db)

fish_samples<-dbTable("fish_samples", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(useSampleMarkRecap=="yes")

# ok, we want to do projects 37 and 38 separately. 37 used AF (anal fin) tags, 38 used PIT tags
fish_info<-dbTable("fish_info", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(sampleID%in%fish_samples$sampleID)%>%
  filter(otu=="largemouth_bass")

fish_data<-inner_join(fish_samples, fish_info, by="sampleID")%>%
  mutate(lakeID=str_split_fixed(sampleID, "_", 2)[,1],
         clipRecapture=as.numeric(clipRecapture),
         clipRecapture=ifelse(is.na(clipRecapture),0,clipRecapture),
         tagged=ifelse(clipApply=="AF", 1, 0))

samples<-unique(fish_data$sampleID)

```

```{r}
# Johnson lake specifically
# arrowhead next

johnson<-fish_data%>%
  filter(lakeID=="JS")

JS_samples<-data.frame(sampleID=unique(johnson$sampleID))%>%
  mutate(method=str_split_fixed(sampleID, "_", 6)[,5],
         sampleDate=str_split_fixed(sampleID, "_", 4)[,3],
         sampleTime=str_split_fixed(sampleID, "_", 5)[,4],
         date_time=ymd_hm(paste(sampleDate, sampleTime, sep="_")),
         # adjust sampleDates for night electrofishing--if method==BE and sampleTime is in the evening before midnight, add one day to date.
         adjust=ifelse(method=="BE" & sampleTime<2359 & sampleTime>1200, 1, 0),
         adj_sampleDate=as.character(ymd(sampleDate)+days(1)),
         batchDate=ifelse(adjust==1, adj_sampleDate, as.character(ymd(sampleDate))),
         batchDate_method=paste(batchDate, method, sep="_"))

johnson_pe<-left_join(johnson, JS_samples[,c("sampleID","batchDate_method")], by="sampleID")

pe_data<-johnson_pe%>%
  group_by(batchDate_method)%>%
  summarize(markedNow=sum(tagged, na.rm=T),
            recapturedNow=sum(clipRecapture))%>%
  mutate(marked_cum=cumsum(markedNow),
         markedPrior=lag(marked_cum),
         markedPrior=ifelse(is.na(markedPrior), 0, markedPrior),
         allFishCaught=markedNow+recapturedNow)

source("schnabel.R")

JS_pe<-schnabel(markedPrior=pe_data$markedPrior, collectedNow=pe_data$allFishCaught, recapturedNow=pe_data$recapturedNow)

ggplot(JS_pe)+
  geom_point(aes(x=event, y=nHat))+
  geom_errorbar(aes(x=event, ymin=nHatLow, ymax=nHatHigh))

```
Now let's try an estimate (for just Johnson) using Stan

```{r}
# pe_data_list<-list(T=nrow(pe_data),
#                    Ct=pe_data$allFishCaught,
#                    Mt=pe_data$markedPrior,
#                   # Rt=pe_data$recapturedNow)
#                    sumRt=sum(pe_data$recapturedNow))

# only giving final counts
# pe_data_list<-list(C=sum(pe_data$allFishCaught),
#                    M=pe_data$markedPrior[nrow(pe_data)],
#                    sumRt=sum(pe_data$recapturedNow))

# found the problem; need to multiply C*M then sum all of them, duh

pe_data_list<-list(T=nrow(pe_data),
                  CtMt=pe_data$allFishCaught*pe_data$markedPrior,
                  Rt=pe_data$recapturedNow)

pe_fit<-stan(
  file="pop_estimate_poisson.stan",
  data=pe_data_list,
  chains=4,
  warmup=1000,
  iter=2000,
  cores=4,
  refresh=0
)


print(pe_fit, pars=c("PE", "lp__"), probs=c(.1,.5,.9))

traceplot(pe_fit, pars=c("PE","lp__"), inc_warmup=FALSE, nrow=2)

```

Problem is actually my model, probably. 
Here's an explanation of mark recap models in Stan https://mc-stan.org/docs/2_22/stan-users-guide/mark-recapture-models.html 


putting together data for multilake PEs

```{r}
# this step is necessary to identify batches. some batches are split between dates because they happened overnight. Date is therefore not a good indicator of batch.
fish_samples<-data.frame(sampleID=unique(fish_data$sampleID))%>%
  mutate(method=str_split_fixed(sampleID, "_", 6)[,5],
         sampleDate=str_split_fixed(sampleID, "_", 4)[,3],
         sampleTime=str_split_fixed(sampleID, "_", 5)[,4],
         date_time=ymd_hm(paste(sampleDate, sampleTime, sep="_")),
         # adjust sampleDates for night electrofishing--if method==BE and sampleTime is in the evening before midnight, add one day to date.
         adjust=ifelse(method=="BE" & sampleTime<2359 & sampleTime>1200, 1, 0),
         adj_sampleDate=as.character(ymd(sampleDate)+days(1)),
         batchDate=ifelse(adjust==1, adj_sampleDate, as.character(ymd(sampleDate))),
         batchDate_method=paste(batchDate, method, sep="_"))

fish_pe<-left_join(fish_data, fish_samples[,c("sampleID","batchDate_method")], by="sampleID")%>%
  group_by(lakeID, batchDate_method)%>%
  summarize(markedNow=sum(tagged, na.rm=T),
            recapturedNow=sum(clipRecapture))%>%
  mutate(marked_cum=cumsum(markedNow),
         markedPrior=lag(marked_cum),
         markedPrior=ifelse(is.na(markedPrior), 0, markedPrior),
         allFishCaught=markedNow+recapturedNow)%>%
  ungroup()

# let's filter to lakes that had at least 1 recapture

recap_count<-fish_pe%>%
  group_by(lakeID)%>%
  summarize(nRecap=sum(recapturedNow))%>%
  arrange(desc(nRecap))%>%
  filter(nRecap>0)


fish_pe_recap<-fish_pe%>%
  filter(lakeID%in%recap_count$lakeID)%>%
  mutate(CtMt=allFishCaught*markedPrior)%>%
  group_by(lakeID)%>%
  summarize(sumCtMt=sum(CtMt),
            sumRt=sum(recapturedNow))

```

I want no pooling in this PE model'

Make list and fit
```{r}
pe_data_all<-list(L=nrow(fish_pe_recap),
                  sumCtMt=fish_pe_recap$sumCtMt,
                  sumRt=fish_pe_recap$sumRt)

pe_all_fit<-stan(file="pop_estimate_poisson_mult_lakes.stan",
                 data=pe_data_all,
                 chains=4,
                 warmup=1000,
                 iter=2000,
                 cores=4,
                 refresh=0)
                 
                 
print(pe_all_fit, pars=c("PE", "lp__"), probs=c(.025,.5,.975))

traceplot(pe_all_fit, pars=c("PE","lp__"), inc_warmup=FALSE, nrow=2)

draws<-extract(pe_all_fit)

pe.draws.df<-as.data.frame(draws)
lakeID<-fish_pe_recap$lakeID

names(pe.draws.df)<-c(lakeID, "likelihood")

pe.draws.long.lognorm<-pe.draws.df%>%
  dplyr::select(AR:WS)%>%
  pivot_longer(cols=everything(), names_to="lakeID", values_to="PE")

ggplot(pe.draws.long.lognorm)+
  geom_histogram(aes(x=PE, fill=lakeID))

pe.draws.long.lognorm%>%
  group_by(lakeID)%>%
  summarize(mean.PE=mean(PE),
            sd.PE=sd(PE))
```
Both gamma and lognormal dists on PE work, but they give different estimates. Place to sensitivity test
ohhh priors matter a lot. with a less specific prior on PE, estimates spread out a lot. 

Compare to gamma

```{r}
pe_data_all<-list(L=nrow(fish_pe_recap),
                  sumCtMt=fish_pe_recap$sumCtMt,
                  sumRt=fish_pe_recap$sumRt)

pe_all_fit<-stan(file="pop_estimate_poisson_mult_lakes.stan",
                 data=pe_data_all,
                 chains=4,
                 warmup=1000,
                 iter=2000,
                 cores=4,
                 refresh=0)
                 
                 
print(pe_all_fit, pars=c("PE", "lp__"), probs=c(.025,.5,.975))

traceplot(pe_all_fit, pars=c("PE","lp__"), inc_warmup=FALSE, nrow=2)

draws<-extract(pe_all_fit)

pe.draws.df<-as.data.frame(draws)
lakeID<-fish_pe_recap$lakeID

names(pe.draws.df)<-c(lakeID, "likelihood")

pe.draws.long.gamma<-pe.draws.df%>%
  dplyr::select(AR:WS)%>%
  pivot_longer(cols=everything(), names_to="lakeID", values_to="PE")

ggplot(pe.draws.long.gamma)+
  geom_histogram(aes(x=PE, fill=lakeID))

pe.draws.long.gamma%>%
  group_by(lakeID)%>%
  summarize(mean.PE=mean(PE),
            sd.PE=sd(PE))


```

The lognormal prior makes the most sense to me both theoretically and based on its PE results. Example: Lake of the Hills (LH) was very small. We also observed a HUGE largemouth bass harvested by an angler from that lake. I would not be at all surprised if the lake had a lower population abundance but larger max size for LMB. 