---
title: "model.results.7.2.24"
output: html_document
date: "2024-07-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, here, lubridate, lme4, loo, rstan, shinystan, truncnorm, MFEUtilities, RColorBrewer, cowplot, bayesPlot)
```

Pull raw data from MFE database
```{r}
rm(list=ls())

# raw catch data
wd<-getwd()
db.dir<-paste0(wd, "/MFEdb/")
db<-"MFEdb_20220405.db"

dbTableList(db.dir, db)

lakes<-dbTable("lakes", fpath=db.dir, dbname=db)
#crew<-dbTable("crew", fpath=db.dir, dbname=db)%>%
#  filter(year%in%c("2018","2019"))
#write.csv(crew, "crew.csv")

# lake data

lakes.key<-lakes%>%
  dplyr::select(lakeID, lakeName, lat, long, WBIC, surfaceArea)
# Found lake missing surface area--135.97 ha
lakes.key[lakes.key$lakeID=="FD","surfaceArea"]<-135.97


projects<-dbTable("projects", fpath=db.dir, dbname=db)

fishSamples<-dbTable("fish_samples", fpath=db.dir, dbname=db)%>%
  filter(projectID%in%c("37") & gear=="AN")%>%
    mutate(nAnglers=as.numeric(nAnglers),
    effort=effort/nAnglers)


fishInfo<-dbTable("fish_info", fpath=db.dir, dbname=db)%>%
  filter(sampleID%in%fishSamples$sampleID)%>%
  filter(str_length(caughtBy)<4)%>%
  mutate(caughtBy=str_trim(caughtBy))%>%
  filter(otu=="largemouth_bass")%>%
  dplyr::select(projectID:caughtBy, comments)%>%
  # join fishing effort
  left_join(fishSamples[,c("lakeID","sampleID","dayOfYear","dateSample","dateTimeSample","crew","effort","effortUnits","nAnglers")], by="sampleID")

# catch rates for each angler trip, correcting for some ambiguous initials first

ALK.lake.date<-c("LV_20190608",
                 "SM_20190615",
                 "WN_20190617",
                 "BY_20190622")

AMK.lake.date<-c("DS_20190613",
                 "BOT_20190615",
                 "SM_20190621",
                 "BOT_20190624",
                 "NH_20190713")

long.crew<-fishSamples%>%
  group_by(sampleID)%>%
  summarize(crew=unique(crew),
            effort=unique(effort))%>%
  # split crew into columns and then pivot longer
  separate("crew", paste("angler", 1:3, sep="_"), sep=", ", extra="drop")%>%
  pivot_longer(cols=angler_1:angler_3, names_to="angler_num", values_to="caughtBy", values_drop_na=T)%>%
  mutate(caughtBy=ifelse(caughtBy=="CMI","CI", caughtBy))%>%
  mutate(date=str_split_fixed(sampleID, "_", 4)[,3],
         lakeID=str_split_fixed(sampleID, "_", 2)[,1],
         lakeID_date=paste(lakeID, date, sep="_"))%>%
  mutate(caughtBy=ifelse(lakeID_date%in%AMK.lake.date, "AMK",
                         ifelse(lakeID_date%in%ALK.lake.date, "ALK", caughtBy)))
  
 #long.crew$date<-NULL
 #long.crew$lakeID<-NULL
 #long.crew$lakeID_date<-NULL
 
 
 all.data<-fishInfo%>%
  mutate(year=year(dateSample))%>%
  left_join(lakes.key, by="lakeID")
  

  
# now get catch rates from angling data and left join to long.crew. empty values can then be replaced with 0

cpue<-all.data%>%
  group_by(sampleID, caughtBy)%>%
  summarize(nCaught=n())



full.data<-long.crew%>%
  left_join(cpue, by=c("sampleID", "caughtBy"))%>%
  mutate(nCaught=ifelse(is.na(nCaught), 0, nCaught))



# join on mark recap data (sumCtRt and sumRt) and surface area

```


code for processing mark recap data

```{r}
fish_samples<-dbTable("fish_samples", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(useSampleMarkRecap=="yes")

# ok, we want to do projects 37 and 38 separately. 37 used AF (anal fin) tags, 38 used PIT tags
fish_info<-dbTable("fish_info", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(sampleID%in%fish_samples$sampleID)%>%
  filter(otu=="largemouth_bass")

fish_data<-inner_join(fish_samples, fish_info, by="sampleID")%>%
  mutate(lakeID=str_split_fixed(sampleID, "_", 2)[,1],
         clipRecapture=as.numeric(clipRecapture),
         clipRecapture=ifelse(is.na(clipRecapture),0,clipRecapture),
         tagged=ifelse(clipApply=="AF", 1, 0))

samples<-unique(fish_data$sampleID)

lakes<-dbTable("lakes", fpath=db.dir)

fish_samples<-data.frame(sampleID=unique(fish_data$sampleID))%>%
  mutate(method=str_split_fixed(sampleID, "_", 6)[,5],
         sampleDate=str_split_fixed(sampleID, "_", 4)[,3],
         sampleTime=str_split_fixed(sampleID, "_", 5)[,4],
         date_time=ymd_hm(paste(sampleDate, sampleTime, sep="_")),
         # adjust sampleDates for night electrofishing--if method==BE and sampleTime is in the evening before midnight, add one day to date.
         adjust=ifelse(method=="BE" & sampleTime<2359 & sampleTime>1200, 1, 0),
         adj_sampleDate=as.character(ymd(sampleDate)+days(1)),
         batchDate=ifelse(adjust==1, adj_sampleDate, as.character(ymd(sampleDate))),
         batchDate_method=paste(batchDate, method, sep="_"))

fish_pe<-left_join(fish_data, fish_samples[,c("sampleID","batchDate_method")], by="sampleID")%>%
  group_by(lakeID, batchDate_method)%>%
  summarize(markedNow=sum(tagged, na.rm=T),
            recapturedNow=sum(clipRecapture))%>%
  mutate(marked_cum=cumsum(markedNow),
         markedPrior=lag(marked_cum),
         markedPrior=ifelse(is.na(markedPrior), 0, markedPrior),
         allFishCaught=markedNow+recapturedNow)%>%
  ungroup()

# let's filter to lakes that had at least 1 recapture

recap_count<-fish_pe%>%
  group_by(lakeID)%>%
  summarize(nRecap=sum(recapturedNow))%>%
  arrange(desc(nRecap))%>%
  filter(nRecap>0)

recap_over_1<-filter(recap_count, nRecap>1)

# surface area for Found lake was missing. Got it from WI DNR (find a lake tool) and converted to hectares
lakes[lakes$lakeID=="FD",]$surfaceArea<-136.0

fish_pe_recap<-fish_pe%>%
  filter(lakeID%in%recap_count$lakeID)%>%
  mutate(CtMt=allFishCaught*markedPrior)%>%
  group_by(lakeID)%>%
  summarize(sumCtMt=sum(CtMt),
            sumRt=sum(recapturedNow))%>%
  ungroup()%>%
  left_join(lakes[,c("lakeID","surfaceArea")], by="lakeID")

```
Now join those datasets and index the unique lakeIDs and caughtBy initials

```{r}
data.join<-full.data%>%
  filter(lakeID%in%fish_pe_recap$lakeID)%>%
  left_join(fish_pe_recap, by="lakeID")


lakeID<-data.frame(lakeID=fish_pe_recap$lakeID,
                   L=seq(1:13),
                   sumCtMt=fish_pe_recap$sumCtMt,
                   sumRt=fish_pe_recap$sumRt,
                   surfaceArea=fish_pe_recap$surfaceArea)

anglerID<-data.frame(caughtBy=unique(data.join$caughtBy),
                     A=seq(1:18))

dateID<-data.frame(date=unique(data.join$date),
                   D=seq(1:42))

data.indexed<-data.join%>%
  left_join(dateID, by="date")%>%
  left_join(anglerID, by="caughtBy")%>%
  left_join(lakeID, by="lakeID")%>%
  mutate(log_effort=log(effort))%>%
  rename("lmbCatch"=nCaught)

# make some prediction data for output


pred_angler<-rep(seq(1:max(data.indexed$A)), each=max(data.indexed$L))
pred_angler_pop<-rep(seq(1:max(data.indexed$L)), max(data.indexed$A))

pred_date<-rep(seq(1:max(data.indexed$D)), each=max(data.indexed$L))
pred_date_pop<-rep(seq(1:max(data.indexed$L)), max(data.indexed$D))

pred_lake<-rep(seq(1:max(data.indexed$L)), each=max(data.indexed$L))
pred_lake_pop<-rep(seq(1:max(data.indexed$L)), max(data.indexed$L))

data.list<-list(N=nrow(data.indexed),
                A=max(data.indexed$A),
                D=max(data.indexed$D),
                L=max(data.indexed$L),
                #Z = max(data.indexed$A)*max(data.indexed$L),
                #Y= max(data.indexed$D)*max(data.indexed$L),
                #X= max(data.indexed$L)*max(data.indexed$L),
                AA=data.indexed$A,
                DD=data.indexed$D,
                LL=data.indexed$L,
                lmbCatch=data.indexed$lmbCatch,
                log_effort=data.indexed$log_effort,
                sumCtMt=lakeID$sumCtMt,
                sumRt=lakeID$sumRt,
                surfaceArea=lakeID$surfaceArea
                # ,
                # pred_angler=pred_angler,
                # pred_angler_pop=pred_angler_pop,
                # pred_date=pred_date,
                # pred_date_pop=pred_date_pop,
                # pred_lake=pred_lake,
                # pred_lake_pop=pred_lake_pop
                )

#pred_df<-data.frame(lakeID=lakeID_pred,
#                    anglerID=anglerID_pred,
#                    dateID=dateID_pred)
```

```{r}
y<-data.list$lmbCatch

fit_no_zinf<-stan(file="noncentered.hierarchical.LINEARIZED.stan",
                 data=data.list,
                 #init=hier.inits,
                 control=list(stepsize=0.1, max_treedepth=15),
                 chains=4,
                 warmup=1000,
                 iter=3000,
                 cores=1,
                 refresh=0)

fit_zinf<-stan(file="catch.model.zinf.scale.random.slope.stan",
                 data=data.list,
                 #init=hier.inits,
                 control=list(stepsize=0.1, max_treedepth=15),
                 chains=4,
                 warmup=1000,
                 iter=3000,
                 cores=1,
                 refresh=0)
launch_shinystan(fit_no_zinf)

draws.no.zinf<-extract(fit_no_zinf)
draws.zinf<-extract(fit_zinf)

pairs(real_fit, pars=c("beta","phi","log_mu_q_a","log_mu_q_d","log_mu_q_l","log_q_mu"))

```
7/3/24
need to check posterior on zinf model compared to nb
Once that's working, try varying effect of anglerID on beta
Materials; https://github.com/QFCatMSU/FW-Bayes/blob/main/week7/lec10.pdf 
Statistical rethinking, chapter on 'models with memory'

model predictions

```{r}

hist(colMeans(posterior_pred_check))

ppc_dens_overlay(data.list$lmbCatch, posterior_pred_check[1:100,])
ggsave(here::here("plots.7.2.24","post.check.100.png"))
```
```{r}
pred1<-posterior_pred_check[1,]
iter1<-ggplot()+
  geom_point(aes(x=data.list$lmbCatch, y=pred1))+
  ylim(0,55)+
  xlim(0,55)+
  geom_abline(intercept=0, slope=1)


meanpred<-colMeans(posterior_pred_check)

meaniter<-ggplot()+
  geom_point(aes(x=data.list$lmbCatch, y=meanpred))+
    ylim(0,55)+
  xlim(0,55)+
  geom_abline(intercept=0, slope=1)

plot_grid(iter1, meaniter)
ggsave(here::here("plots.7.2.24", "obs.vs.pred.png"))
```


Density plot posteriors for beta, phi, log_q_mu, log_q_a,d,l

```{r}
beta<-draws$beta
phi<-draws$phi
log_q_mu<-draws$log_q_mu

log_q_a<-draws$log_q_a
log_q_d<-draws$log_q_d
log_q_l<-draws$log_q_l

beta.plot<-ggplot()+
  geom_density(aes(x=beta))+
  theme_bw()

phi.plot<-ggplot()+
  geom_density(aes(x=phi))+
  theme_bw()

log.q.mu.plot<-ggplot()+
  geom_density(aes(log_q_mu))+
  theme_bw()
beta.plot
phi.plot
log.q.mu.plot

plot_grid(beta.plot, phi.plot, log.q.mu.plot)
ggsave(here::here("plots.7.2.24","params.png"))
```

```{r}
popDensity_fun<-function(draws){
  
  popDensity<-data.frame(draws$popDensity)
  names(popDensity)<-lakeID$lakeID

  popDensityLong<-popDensity%>%
    pivot_longer(cols=everything(), names_to="lakeID", values_to="popDensity")

  palette<-c(brewer.pal(12, "Paired"), "gray")

  ggplot(popDensityLong)+
    geom_density(aes(x=popDensity, fill=lakeID))+
    scale_fill_manual(values=palette)+
    facet_wrap(.~lakeID, nrow=3, scales="free_x")+
    theme_bw()
  
}

log_q_a_fun<-function(draws){
  q_a<-data.frame(draws$q_a)
  log_q_a<-data.frame(draws$log_q_a)
  names(log_q_a)<-anglerID$caughtBy

  log_q_aLong<-log_q_a%>%
    pivot_longer(cols=everything(), names_to="anglerID", values_to="log_q_a")

  palette<-c("#78b98f", "#de0ca3", "#74ee65", "#69306e", "#59a20c", "#903be2", "#c0e15c",
             "#891c1a", "#64d4fd", "#0a4f4e", "#e7ad79", "#1945c5", "#edb1ff", "#683d0d", "#fe707d",
             "#445a06", "#4787c9", "#fbd127")

  ggplot(log_q_aLong)+
    geom_density(aes(x=log_q_a, fill=anglerID))+
    geom_vline(xintercept=0, linetype="dashed")+
    scale_fill_manual(values=palette)+
    facet_wrap(.~anglerID, nrow=4)+
    theme_bw()

}

log_q_l_fun<-function(draws){
  log_q_l<-data.frame(draws$log_q_l)
  names(log_q_l)<-lakeID$lakeID

  log_q_lLong<-log_q_l%>%
  pivot_longer(cols=everything(), names_to="lakeID", values_to="log_q_l")


ggplot(log_q_lLong)+
    geom_density(aes(x=log_q_l, fill=lakeID))+
    geom_vline(xintercept=0, linetype="dashed")+
 # scale_fill_manual(values=palette)+
    facet_wrap(.~lakeID, nrow=4)+
    theme_bw()
}

log_q_d_fun<-function(draws){
  log_q_d<-data.frame(draws$log_q_d)
  names(log_q_d)<-dateID$date

  log_q_dLong<-log_q_d%>%
    pivot_longer(cols=everything(), names_to="date", values_to="log_q_d")%>%
    mutate(date=ymd(date))%>%
    group_by(date)%>%
    summarize(mean_log_q_d=mean(log_q_d),
            sd_log_q_d=sd(log_q_d),
            upper_95=mean_log_q_d+1.96*sd_log_q_d,
            lower_95=mean_log_q_d-1.96*sd_log_q_d)%>%
    ungroup()%>%
   mutate(year=year(date))


  ggplot(log_q_dLong)+
    geom_point(aes(x=date, y=mean_log_q_d))+
    geom_errorbar(aes(x=date, ymin=lower_95, ymax=upper_95))+
    facet_wrap(.~year, nrow=2, scales="free_x")+
    theme_bw()

}

```

```{r}
log_q_a_fun(draws=draws)
ggsave(here::here("plots.7.2.24","log.q.a.png"))
log_q_l_fun(draws=draws)
ggsave(here::here("plots.7.2.24","log.q.l.png"))

log_q_d_fun(draws=draws)
ggsave(here::here("plots.7.2.24","log.q.d.png"))


popDensity_fun(draws=draws)
ggsave(here::here("plots.7.2.24","pop.density.png"))

```


aking charts

VPC comparison on link and observation scales

```{r}
part_var<-data.frame(glmm_r2=draws$glmm_r2,
                     fixed_r2=draws$fixed_r2,
                     ICC_adj=draws$ICC_adj,
                     ICC_adj_a=draws$ICC_adj_a,
                     ICC_adj_d=draws$ICC_adj_d,
                     ICC_adj_l=draws$ICC_adj_l,
                     part_r2_popDensity=draws$part_r2_popDensity,
                     vpc_a=draws$vpc_a,
                     vpc_d=draws$vpc_d,
                     vpc_l=draws$vpc_l,
                     vpc_a_link=draws$vpc_a_link,
                     vpc_d_link=draws$vpc_d_link,
                     vpc_l_link=draws$vpc_l_link)
ggplot(part_var)+
  geom_density(aes(x=glmm_r2))+
  theme_bw()
ggsave(here::here("plots.7.2.24", "r2.glmm.link.scale.png"))


ggplot(part_var)+
  geom_density(aes(x=fixed_r2))+
  theme_bw()
ggsave(here::here("plots.7.2.24", "r2.fixed.link.scale.png"))


ggplot(part_var)+
  geom_density(aes(x=ICC_adj))+
  theme_bw()

ggplot(part_var)+
  geom_density(aes(x=ICC_adj_a))+
  theme_bw()
ggplot(part_var)+
  geom_density(aes(x=ICC_adj_d))+
  theme_bw()
ggplot(part_var)+
  geom_density(aes(x=ICC_adj_l))+
  theme_bw()



ggplot(part_var)+
  geom_density(aes(x=part_r2_popDensity), fill="purple")+
  theme_bw()
# model run problems if I bound lower limit at 0


angler<-ggplot(part_var)+
  geom_density(aes(x=vpc_a), fill="orange")+
  ggtitle("Angler VPC")+
  xlim(0,1)+
  theme_bw()

day<-ggplot(part_var)+
  geom_density(aes(x=vpc_d), fill="yellow")+
  ggtitle("Date VPC")+
  xlim(0,1)+
  theme_bw()

lake<-ggplot(part_var)+
  geom_density(aes(x=vpc_l), fill="blue")+
  ggtitle("Lake VPC")+
  xlim(0,1)+
  theme_bw()

library(cowplot)

plot_grid(angler, day, lake, nrow=1)
ggsave(here::here("plots.7.2.24", "vpc.obs.scale.png"))

angler_link<-ggplot(part_var)+
  geom_density(aes(x=vpc_a_link), fill="orange")+
  ggtitle("Angler VPC")+
  xlim(0,1)+
  theme_bw()

day_link<-ggplot(part_var)+
  geom_density(aes(x=vpc_d_link), fill="yellow")+
  ggtitle("Date VPC")+
  xlim(0,1)+
  theme_bw()

lake_link<-ggplot(part_var)+
  geom_density(aes(x=vpc_l_link), fill="blue")+
  ggtitle("Lake VPC")+
  xlim(0,1)+
  theme_bw()


plot_grid(angler_link, day_link, lake_link, nrow=1)
ggsave(here::here("plots.7.2.24", "vpc.link.scale.png"))


```


Next plotting effect sizes

```{r}
popDensity<-as.data.frame(draws$popDensity)
names(popDensity)<-lakeID$lakeID

popDensity_long<-popDensity%>%
  pivot_longer(cols=everything(),  names_to="lakeID", values_to="popDensity")

ggplot(popDensity_long)+
  geom_violin(aes(x=lakeID, y=popDensity))+
  ylim(0,300)+
  theme_bw()
ggsave(here::here("plots.7.2.24", "violin.catch.by.lakeID.png"))


popDensity_mean<-colMeans(popDensity)
popDensity_mean_df<-data.frame(lakeID=names(popDensity_mean),
                               popDensity_mean=popDensity_mean,
                               lakeNum=lakeID$L)
popDensity_order<-popDensity_mean_df%>%
  arrange(popDensity_mean)

# come back to this when model's done running, set up dfs based on what plots need
pred_catch_box<-as.data.frame(draws$predictions_popDensity)
names(pred_catch_box)<-lakeID$lakeID

pred_catch_box_long<-pred_catch_box%>%
  pivot_longer(cols=everything(), names_to="lakeID", values_to="pred_catch")%>%
  mutate(lakeID=factor(lakeID, levels=popDensity_order$lakeID))

pop.box.plot<-ggplot(pred_catch_box_long)+
  geom_violin(aes(x=lakeID, y=pred_catch, fill=lakeID))+
  theme_bw()

pop.box.plot
ggsave(here::here("plots.7.2.24", "violin.catch.by.popDensity.ordered.png"))


```
In order of population density (make sure to provide table)

May want to drop HT and WB at some point to see how the results change

These are catch predictions for each angler on an average day, average lake, and population density of Johnson lake (JS)

ordering anglers by angler effect, same for dates and lakes

```{r}
popDensity_order

log_q_a<-draws$log_q_a
log_q_a_mean<-colMeans(log_q_a)
log_q_a_mean_df<-data.frame(anglerID=anglerID$A,
                               log_q_a_mean=log_q_a_mean)
log_q_a_order<-log_q_a_mean_df%>%
  arrange(log_q_a_mean)


log_q_d<-draws$log_q_d
log_q_d_mean<-colMeans(log_q_d)
log_q_d_mean_df<-data.frame(dateID=dateID$D,
                               log_q_d_mean=log_q_d_mean)
log_q_d_order<-log_q_d_mean_df%>%
  arrange(log_q_d_mean)


log_q_l<-draws$log_q_l
log_q_l_mean<-colMeans(log_q_l)
log_q_l_mean_df<-data.frame(lakeID=lakeID$L,
                               log_q_l_mean=log_q_l_mean)
log_q_l_order<-log_q_l_mean_df%>%
  arrange(log_q_l_mean)



```

```{r}
angler_pred<-as.data.frame(draws$predictions_box_angler)

names(angler_pred)<-anglerID$A


# let's order them by log_q_a value

angler_pred_long<-angler_pred%>%
  pivot_longer(cols=everything(), names_to="anglerID", values_to="pred_catch")%>%
  mutate(anglerID=factor(anglerID, levels=log_q_a_order$anglerID))

angler.box<-ggplot(angler_pred_long)+
  geom_violin(aes(x=anglerID, y=pred_catch))+
  theme_bw()

angler.box
ggsave(here::here("plots.7.2.24", "violin.catch.by.angler.png"))

```

```{r}
date_pred<-as.data.frame(draws$predictions_box_date)

names(date_pred)<-dateID$D


# let's order them by log_q_a value

date_pred_long<-date_pred%>%
  pivot_longer(cols=everything(), names_to="dateID", values_to="pred_catch")%>%
  mutate(dateID=factor(dateID, levels=log_q_d_order$dateID))

date.box<-ggplot(date_pred_long)+
  geom_violin(aes(x=dateID, y=pred_catch))+
  theme_bw()

date.box
ggsave(here::here("plots.7.2.24", "violin.catch.by.date.ordered.png"))


```

and just in order by date

```{r}
date_pred_long<-date_pred%>%
  pivot_longer(cols=everything(), names_to="dateID", values_to="pred_catch")%>%
  mutate(dateID=as.factor(as.numeric(dateID)))

date.box<-ggplot(date_pred_long)+
  geom_violin(aes(x=dateID, y=pred_catch))+
  theme_bw()

date.box
ggsave(here::here("plots.7.2.24", "violin.catch.by.date.temporal.png"))


```
```{r}
lake_pred<-as.data.frame(draws$predictions_box_lake)

names(lake_pred)<-lakeID$L


# let's order them by log_q_a value

lake_pred_long<-lake_pred%>%
  pivot_longer(cols=everything(), names_to="lakeID", values_to="pred_catch")%>%
  mutate(lakeID=factor(lakeID, levels=log_q_l_order$lakeID))

lake.box<-ggplot(lake_pred_long)+
  geom_violin(aes(x=lakeID, y=pred_catch))+
  theme_bw()

lake.box
ggsave(here::here("plots.7.2.24", "violin.catch.by.lake.ordered.png"))

```



Now I want to include population density as well. These will have to be mean predictions (and I'll have to note that credible intervals are not displayed)

```{r}
# mean population densities

angler<-colMeans(draws$predictions_pop_angler)
angler.df<-data.frame(anglerID=pred_angler,
                      lakeNum=pred_angler_pop,
                      pred_catch=angler
                      )%>%
  left_join(popDensity_order, by="lakeNum")

ggplot(angler.df)+
  geom_point(aes(x=popDensity_mean, y=pred_catch, color=as.factor(anglerID)), size=2)+
  geom_smooth(aes(x=popDensity_mean, y=pred_catch, color=as.factor(anglerID)),method="gam", formula=y~s(log(x)),se=F)+
  theme_bw()
ggsave(here::here("plots.7.2.24","angler.popDensity.png"))
```

```{r}

date<-colMeans(draws$predictions_pop_date)

date.df<-data.frame(dateID=pred_date,
                      lakeNum=pred_date_pop,
                      pred_catch=date
                      )%>%
  left_join(popDensity_order, by="lakeNum")

ggplot(date.df)+
  geom_point(aes(x=popDensity_mean, y=pred_catch, color=as.factor(dateID)), size=2)+
  geom_smooth(aes(x=popDensity_mean, y=pred_catch, color=as.factor(dateID)),method="gam", formula=y~s(log(x)),se=F)+
  theme_bw()
ggsave(here::here("plots.7.2.24","date.popDensity.png"))


```

```{r}
lake<-colMeans(draws$predictions_pop_lake)

lake.df<-data.frame(lakeID=pred_lake,
                      lakeNum=pred_lake_pop,
                      pred_catch=lake
                      )%>%
  left_join(popDensity_order, by="lakeNum")

ggplot(lake.df)+
  geom_point(aes(x=popDensity_mean, y=pred_catch, color=as.factor(lakeID.x)), size=2)+
  geom_smooth(aes(x=popDensity_mean, y=pred_catch, color=as.factor(lakeID.x)),method="gam", formula=y~s(log(x)),se=F)+
  theme_bw()

ggsave(here::here("plots.7.2.24","lake.popDensity.png"))

```


