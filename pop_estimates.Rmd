---
title: "population_estimates"
output: html_document
date: "2024-04-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, here, FSA, RSQLite, MFEUtilities, lubridate)
```

```{r}
wd<-getwd()
db.dir<-paste0(wd, "/MFEdb/")
db<-"MFEdb_20220405.db"

dbTableList(db.dir, db)

```
```{r}
metadata<-dbTable("metadata", fpath=db.dir)
projects<-dbTable("projects", fpath=db.dir)

# not useful
#samples<-dbTable("samples", fpath=db.dir)%>%
#  filter(projectID%in%c("37", "38"))
```


we want experimental anglingn data from 2018 and 2019 as well as electrofishing survey data. This is projectID 37. If I want Camp Lake as well, that's projectID 38. (but see if it's in 37 first)

```{r}
fish_samples<-dbTable("fish_samples", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(useSampleMarkRecap=="yes")

# ok, we want to do projects 37 and 38 separately. 37 used AF (anal fin) tags, 38 used PIT tags
fish_info<-dbTable("fish_info", fpath=db.dir)%>%
  filter(projectID%in%c("37"))%>%
  filter(sampleID%in%fish_samples$sampleID)%>%
  filter(otu=="largemouth_bass")

fish_data<-inner_join(fish_samples, fish_info, by="sampleID")%>%
  mutate(lakeID=str_split_fixed(sampleID, "_", 2)[,1],
         clipRecapture=as.numeric(clipRecapture),
         clipRecapture=ifelse(is.na(clipRecapture),0,clipRecapture),
         tagged=ifelse(clipApply=="AF", 1, 0))

samples<-unique(fish_data$sampleID)
```
Comparing to Cam's estimates
I found the mismatch--sampleDate isn't a good separator because electrofishing happened overnight. So one sampling day/batch can happen across two dates. 
```{r}
# Johnson lake specifically

johnson<-fish_data%>%
  filter(lakeID=="JS")

JS_samples<-data.frame(sampleID=unique(johnson$sampleID))%>%
  mutate(method=str_split_fixed(sampleID, "_", 6)[,5],
         sampleDate=str_split_fixed(sampleID, "_", 4)[,3],
         sampleTime=str_split_fixed(sampleID, "_", 5)[,4],
         date_time=ymd_hm(paste(sampleDate, sampleTime, sep="_")),
         # adjust sampleDates for night electrofishing--if method==BE and sampleTime is in the evening before midnight, add one day to date.
         adjust=ifelse(method=="BE" & sampleTime<2359 & sampleTime>1200, 1, 0),
         adj_sampleDate=as.character(ymd(sampleDate)+days(1)),
         batchDate=ifelse(adjust==1, adj_sampleDate, as.character(ymd(sampleDate))),
         batchDate_method=paste(batchDate, method, sep="_"))

johnson_pe<-left_join(johnson, JS_samples[,c("sampleID","batchDate_method")], by="sampleID")

pe_data<-johnson_pe%>%
  group_by(batchDate_method)%>%
  summarize(markedNow=sum(tagged, na.rm=T),
            recapturedNow=sum(clipRecapture))%>%
  mutate(marked_cum=cumsum(markedNow),
         markedPrior=lag(marked_cum),
         markedPrior=ifelse(is.na(markedPrior), 0, markedPrior),
         allFishCaught=markedNow+recapturedNow)

source("schnabel.R")

JS_pe<-schnabel(markedPrior=pe_data$markedPrior, collectedNow=pe_data$allFishCaught, recapturedNow=pe_data$recapturedNow)

ggplot(JS_pe)+
  geom_point(aes(x=event, y=nHat))+
  geom_errorbar(aes(x=event, ymin=nHatLow, ymax=nHatHigh))

```

Try Towanda?

```{r}
towanda<-fish_data%>%
  filter(lakeID=="TO")

TO_samples<-data.frame(sampleID=unique(towanda$sampleID))%>%
  mutate(method=str_split_fixed(sampleID, "_", 6)[,5],
         sampleDate=str_split_fixed(sampleID, "_", 4)[,3],
         sampleTime=str_split_fixed(sampleID, "_", 5)[,4],
         date_time=ymd_hm(paste(sampleDate, sampleTime, sep="_")),
         # adjust sampleDates for night electrofishing--if method==BE and sampleTime is in the evening before midnight, add one day to date.
         adjust=ifelse(method=="BE" & sampleTime<2359 & sampleTime>1200, 1, 0),
         adj_sampleDate=as.character(ymd(sampleDate)+days(1)),
         batchDate=ifelse(adjust==1, adj_sampleDate, as.character(ymd(sampleDate))),
         batchDate_method=paste(batchDate, method, sep="_"))

towanda_pe<-left_join(towanda, TO_samples[,c("sampleID","batchDate_method")], by="sampleID")

pe_data<-towanda_pe%>%
  group_by(batchDate_method)%>%
  summarize(markedNow=sum(tagged, na.rm=T),
            recapturedNow=sum(clipRecapture))%>%
  mutate(marked_cum=cumsum(markedNow),
         markedPrior=lag(marked_cum),
         markedPrior=ifelse(is.na(markedPrior), 0, markedPrior),
         allFishCaught=markedNow+recapturedNow)

source("schnabel.R")

TO_pe<-schnabel(markedPrior=pe_data$markedPrior, collectedNow=pe_data$allFishCaught, recapturedNow=pe_data$recapturedNow)

ggplot(TO_pe)+
  geom_point(aes(x=event, y=nHat))+
  geom_errorbar(aes(x=event, ymin=nHatLow, ymax=nHatHigh))

```


Multiplecensus mark recapture population estimates, Schnabel with Chapman adjustment
Using FSA package to begin with, 
  initial population size e stimated from: 
  
  M: vector of number of marked fish prior to sample i (sum of M is total number of fish marked)
  n: vector of number of captured fish in sample i (this is Ct in book--total sample taken day t)
  m: vector of  number of recaptured fish in ith sample (this is Rt in book--number of recaptures in sample Ct)
  R: vector of total n umber of fish that are marked and returned to population in ith sample (sum of R is total recaptures during experiment)
  
  305 observations have no clip applied and no clip recapture
  
  
  

```{r}
check<-filter(fish_vars, is.na(clipApply) & is.na(clipRecapture))
check.sample<-unique(check$sampleID)

fish_vars<-fish_info%>%
  # filter to project 37--tagged with PIT tag
  filter(projectID=="37")%>%
  mutate(clipRecapture=as.numeric(clipRecapture),
         tagged=ifelse(clipApply=="AF",1,0),
         sampleDate=ymd(str_split_fixed(sampleID, "_", 4)[,3]),
         lakeID=str_split_fixed(sampleID, "_", 2)[,1])%>%
  #  group by sampling event
  group_by(sampleID)%>%
  # summarize number of fish 1) caught, 2) tagged, 3)  recaptured
  summarize(nCaught=n(),
            nTagged=sum(tagged, na.rm=T),
            nTagged=n(),
            nRecap=sum(clipRecapture, na.rm=T),
            lakeID=unique(lakeID),
            sampleDate=unique(sampleDate))%>%
  ungroup()%>%
  group_by(lakeID)%>%
  arrange(sampleDate, .by_group=TRUE)%>%
  mutate(nMarksCum=cumsum(nTagged),
         nMarksPrev=lag(nMarksCum),
         nMarksPrev=ifelse(is.na(nMarksPrev), 0, nMarksPrev))%>%
  ungroup()


# finding good starting lake
nRecap<-fish_vars%>%
  group_by(lakeID)%>%
  summarize(nRecap=sum(nRecap))%>%
  ungroup()%>%
  filter(nRecap>0)

theseLakes<-nRecap$lakeID
# let's pull 1 lake to start, then if that works okay, i'll apply it across a list
# wow, that's not a lot of recaps

fish_vars_f<-fish_vars%>%
  filter(lakeID%in%theseLakes)


JS_test<-filter(fish_vars, lakeID=="JS")

JS_estimate<-mrClosed(M=JS_test$nMarksPrev,
                      n=JS_test$nCaught,
                      m=JS_test$nRecap,
                      R=JS_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)

# try other package
library(fishmethods)
JS_other<-schnabel(catch=JS_test$nCaught,
                   recaps=JS_test$nRecap,
                   newmarks=JS_test$nTagged)

AR_test<-filter(fish_vars, lakeID=="AR")
AR_estimate<-mrClosed(M=AR_test$nMarksPrev,
                      n=AR_test$nCaught,
                      m=AR_test$nRecap,
                      R=AR_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
  

BA_test<-filter(fish_vars, lakeID=="BA")
BA_estimate<-mrClosed(M=BA_test$nMarksPrev,
                      n=BA_test$nCaught,
                      m=BA_test$nRecap,
                      R=BA_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
FD_test<-filter(fish_vars, lakeID=="FD")
FD_estimate<-mrClosed(M=FD_test$nMarksPrev,
                      n=FD_test$nCaught,
                      m=FD_test$nRecap,
                      R=FD_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
HT_test<-filter(fish_vars, lakeID=="HT")
HT_estimate<-mrClosed(M=HT_test$nMarksPrev,
                      n=HT_test$nCaught,
                      m=HT_test$nRecap,
                      R=HT_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
LC_test<-filter(fish_vars, lakeID=="LC")
LC_estimate<-mrClosed(M=LC_test$nMarksPrev,
                      n=LC_test$nCaught,
                      m=LC_test$nRecap,
                      R=LC_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
LH_test<-filter(fish_vars, lakeID=="LH")
LH_estimate<-mrClosed(M=LH_test$nMarksPrev,
                      n=LH_test$nCaught,
                      m=LH_test$nRecap,
                      R=LH_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
LR_test<-filter(fish_vars, lakeID=="LR")
LR_estimate<-mrClosed(M=LR_test$nMarksPrev,
                      n=LR_test$nCaught,
                      m=LR_test$nRecap,
                      R=LR_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
LT_test<-filter(fish_vars, lakeID=="LT")
LT_estimate<-mrClosed(M=LT_test$nMarksPrev,
                      n=LT_test$nCaught,
                      m=LT_test$nRecap,
                      R=LT_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
TO_test<-filter(fish_vars, lakeID=="TO")
TO_estimate<-mrClosed(M=TO_test$nMarksPrev,
                      n=TO_test$nCaught,
                      m=TO_test$nRecap,
                      R=TO_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
WB_test<-filter(fish_vars, lakeID=="WB")
WB_estimate<-mrClosed(M=WB_test$nMarksPrev,
                      n=WB_test$nCaught,
                      m=WB_test$nRecap,
                      R=WB_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
WC_test<-filter(fish_vars, lakeID=="WC")
WC_estimate<-mrClosed(M=WC_test$nMarksPrev,
                      n=WC_test$nCaught,
                      m=WC_test$nRecap,
                      R=WC_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)
WS_test<-filter(fish_vars, lakeID=="WS")
WS_estimate<-mrClosed(M=WS_test$nMarksPrev,
                      n=WS_test$nCaught,
                      m=WS_test$nRecap,
                      R=WS_test$nTagged,
                      method="Schnabel",
                      chapman.mod=TRUE)


```
Hm. This is very different from previous dataset. Did they assume that all fish had been marked?

https://www.zoology.ubc.ca/~krebs/downloads/krebs_chapter_02_2017.pdf
Trying manually: 
```{r}
JS_estimate_manual<-JS_test%>%
  mutate(ct_mt=nCaught*nMarksPrev)%>%
  summarize(PE=sum(ct_mt)/sum(nRecap))
```

What if I assume those blank AF cells were a mistake?

```{r}
fish_vars<-fish_info%>%
  # filter to project 37--tagged with PIT tag
  filter(projectID=="37")
  mutate(clipRecapture=as.numeric(clipRecapture),
        # tagged=ifelse(clipApply=="AF",1,0),
         sampleDate=ymd(str_split_fixed(sampleID, "_", 4)[,3]),
         lakeID=str_split_fixed(sampleID, "_", 2)[,1])%>%
  #  group by sampling event
  group_by(sampleID)%>%
  # summarize number of fish 1) caught, 2) tagged, 3)  recaptured
  summarize(nCaught=n(),
            nTagged=sum(tagged, na.rm=T),
            nRecap=sum(clipRecapture, na.rm=T),
            lakeID=unique(lakeID),
            sampleDate=unique(sampleDate))%>%
  ungroup()%>%
  group_by(lakeID)%>%
  arrange(sampleDate, .by_group=TRUE)%>%
  mutate(nMarksCum=cumsum(nTagged),
         nMarksPrev=lag(nMarksCum),
         nMarksPrev=ifelse(is.na(nMarksPrev), 0, nMarksPrev))%>%
  ungroup()

```

