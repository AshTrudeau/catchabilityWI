---
title: "comparison.trip.catchability"
output: html_document
date: "2024-03-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, wdnr.fmdb, wdnr.gis, lubridate, here, lme4, glmmTMB, DHARMa, emmeans, effects)

```

Now comparing statistical modeling outcomes for trip-level angling cpue vs. population density (from PEs) or relative abundance (electrofishing cpe)

```{r}
# walleye data

cpue.pe.wye<-read_csv(here::here("data","indiv.level.cpue.pe.walleye.csv"))%>%
  mutate(ln.pop.density=log(pop.density))%>%
  ungroup()%>%
  mutate(sample.date=ymd(sample.date),
         month=month(sample.date))%>%
  filter(!is.na(pop.density)&!is.na(cpue))%>%
  filter(cpue<20)

ef.cpe.wye<-read_csv(here::here("data","dnr.ef.cpe.walleye.lmb.csv"))%>%
filter(species=="walleye" & gear=="boom_shocker")%>%
  mutate(km.shocked=total_effort*1.61,
         cpe_km=total_catch/km.shocked)%>%
  filter(km.shocked>1)%>%
  group_by(wbic, year)%>%
  summarize(mean_cpe_km=mean(cpe_km),
            sd_cpe_km=sd(cpe_km),
            n_ef_surveys=n())%>%
  ungroup()

# join by year and wbic to walleye cpue

cpue.ef.cpe.wye<-cpue.pe.wye%>%
  dplyr::select(county:shore.length)%>%
  left_join(ef.cpe.wye, by=c("wbic","year"))%>%
  filter(!is.na(mean_cpe_km) & !is.na(cpue))%>%
  mutate(ln.ef.cpe=log(mean_cpe_km))%>%
  filter(cpue<20)%>%
  mutate(month=as.factor(month(sample.date)))
  

# lmb data
cpue.ef.cpe.lmb<-read_csv(here::here("data","indiv.level.cpue.ef.cpe.lmb.csv"))%>%
  dplyr::select(county:shore.length)%>%
  filter(!is.na(mean_cpe_km) & !is.na(cpue))%>%
  mutate(ln.ef.cpe=log(mean_cpe_km))%>%
  filter(cpue<20)%>%
  mutate(month=as.factor(month(sample.date)))
```
Starting with walleye pe data: cpue.pe.wye

```{r}
ggplot(cpue.pe.wye)+
  geom_point(aes(x=pop.density, y=cpue))+
  theme_bw()


ggplot(cpue.pe.wye)+
  geom_point(aes(x=ln.pop.density, y=log(cpue+0.01)))+
  theme_bw()
```


```{r}
mod.null.wye.pe<-glmmTMB(cpue~.pop.density + month, 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.pop.density + month)

mod.wbic.wye.pe<-glmmTMB(cpue~.pop.density + month+(1|wbic) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.pop.density + month+(1|wbic))

mod.wbic.year.wye.pe<-glmmTMB(cpue~.pop.density + month+(1|wbic)+(1|year) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.pop.density + month+(1|wbic)+(1|year))

mod.wbic.day.wye.pe<-glmmTMB(cpue~.pop.density + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.pop.density +
                 month+(1|wbic)+(1|sample.date))

mod.wbic.year.day.wye.pe<-glmmTMB(cpue~.pop.density + month+(1|wbic)+(1|year)+(1|sample.date) , 
                  data=cpue.pe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.pop.density +
                 month+(1|wbic)+(1|year)+(1|sample.date))

AIC(mod.null.wye.pe, mod.wbic.wye.pe, mod.wbic.year.wye.pe, mod.wbic.day.wye.pe, mod.wbic.year.day.wye.pe)

sim.resid<-simulateResiduals(mod.wbic.year.day.wye.pe)
plot(sim.resid)

mod.wye.pe<-mod.wbic.year.day.wye.pe
```
```{r}
summary(mod.wye.pe)
performance::r2(mod.wye.pe)
```
woof, incredibly low r2

```{r}
cpue.pe.wye$mod.pred<-predict(mod.wye.pe, type="response")

ggplot(cpue.pe.wye)+
  geom_point(aes(x=pop.density, y=cpue))+
  geom_point(aes(x=pop.density, y=mod.pred), color="red")+
  theme_bw()
```
now walleye ef cpe

```{r}
ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  theme_bw()


ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=ln.ef.cpe, y=log(cpue+0.01)))+
  theme_bw()
```


```{r}
mod.null.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month, 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month)

mod.wbic.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic))

mod.wbic.year.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic)+(1|year))

mod.wbic.day.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|sample.date))

mod.wbic.year.day.wye.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year)+(1|sample.date) , 
                  data=cpue.ef.cpe.wye, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|year)+(1|sample.date))

AIC(mod.null.wye.ef.cpe, mod.wbic.wye.ef.cpe, mod.wbic.year.wye.ef.cpe, mod.wbic.day.wye.ef.cpe, mod.wbic.year.day.wye.ef.cpe)

sim.resid<-simulateResiduals(mod.wbic.year.day.wye.ef.cpe)
plot(sim.resid)

mod.wye.ef.cpe<-mod.wbic.year.day.wye.ef.cpe
```
```{r}
summary(mod.wye.ef.cpe)
performance::r2(mod.wye.ef.cpe)
```
low r2, but actually higher than the model fit to PEs

```{r}
cpue.ef.cpe.wye$mod.pred<-predict(mod.wye.ef.cpe, type="response")

ggplot(cpue.ef.cpe.wye)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  geom_point(aes(x=mean_cpe_km, y=mod.pred), color="red")+
  theme_bw()
```


And LMB ef cpe


```{r}
ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  theme_bw()


ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=ln.ef.cpe, y=log(cpue+0.01)))+
  theme_bw()
```
Visually, there's already less of a distinct pattern compared to walleye

Convergence issues if I fit the model with month as a covariate. Looking at a histogram of months in the data, I may see the problem: 

```{r}
hist(as.numeric(cpue.ef.cpe.lmb$month))
```
I'm going to adjust the month predictor; 5, 6, 7, 8, 9, 10 will remain as dummy variables; 1, 2, 3, 4, 11, and 12 will be baseline

```{r}
cpue.ef.cpe.lmb$month<-ifelse(cpue.ef.cpe.lmb$month%in%c(1,2,3,4,11,12), 0, cpue.ef.cpe.lmb$month)
hist(cpue.ef.cpe.lmb$month)

cpue.ef.cpe.lmb$month<-as.factor(cpue.ef.cpe.lmb$month)
str(cpue.ef.cpe.lmb$month)
```


```{r}
mod.null.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month, 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month)

mod.wbic.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic))

mod.wbic.year.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe + month+(1|wbic)+(1|year))

mod.wbic.day.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|sample.date) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|sample.date))

mod.wbic.year.day.lmb.ef.cpe<-glmmTMB(cpue~.ef.cpe + month+(1|wbic)+(1|year)+(1|sample.date) , 
                  data=cpue.ef.cpe.lmb, family=glmmTMB::lognormal(link="log"),
               ziformula=~.ef.cpe +
                 month+(1|wbic)+(1|year)+(1|sample.date))

AIC(mod.null.lmb.ef.cpe, mod.wbic.lmb.ef.cpe, mod.wbic.year.lmb.ef.cpe, mod.wbic.day.lmb.ef.cpe, mod.wbic.year.day.lmb.ef.cpe)

sim.resid<-simulateResiduals(mod.wbic.year.day.lmb.ef.cpe)
plot(sim.resid)

mod.lmb.ef.cpe<-mod.wbic.year.day.lmb.ef.cpe
```
```{r}
summary(mod.lmb.ef.cpe)
performance::r2(mod.lmb.ef.cpe)
```
low, but like ef.cpue.wye, not as low as model using PEs

```{r}
cpue.ef.cpe.lmb$mod.pred<-predict(mod.lmb.ef.cpe, type="response")

ggplot(cpue.ef.cpe.lmb)+
  geom_point(aes(x=mean_cpe_km, y=cpue))+
  geom_point(aes(x=mean_cpe_km, y=mod.pred), color="red")+
  theme_bw()
```

For final comparison, fishscapes data, cpue vs PE and cpue vs ef cpe


```{r}
fishscapes.pe<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))%>%
  filter(!is.na(pop.density))

fishscapes.ef.cpe<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))%>%
  filter(!is.na(efCPE))

fishscapes.full<-read_csv(here::here("data","fishscapes.cpue.pe.ef.cpe.csv"))

all_equal(fishscapes.pe, fishscapes.ef.cpe)
# good; just need the one


fishscapes<-fishscapes.pe%>%
  mutate(cpue=anCPUE,
         ln.cpue=log(cpue+0.01),
         month=month(date))%>%
  rename("wbic"=WBIC,
         "ef.cpe"=efCPE)%>%
  mutate(wbic=as.factor(wbic),
         year=as.factor(year),
         month=as.factor(month))
  

ggplot(fishscapes)+
  geom_point(aes(x=pop.density, y=cpue))+
  theme_bw()


ggplot(fishscapes)+
  geom_point(aes(x=ln.pop.density, y=ln.cpue))

hist(as.numeric(fishscapes$month))
```

Fewer months than dnr data; could still use month or day of year

instead of date random effect and month as a fixed effect, adding day of year as quadratic fixed effect.
date will still be tested as a random effect in some models

previous convergence problems (and mismatch with previous models) was caused by year being numeric instead of a factor. silly goose.

```{r}

mod.null.lmb.pe<-glmmTMB(cpue~ln.pop.density + year, 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year)


mod.lakeID.lmb.pe<-glmmTMB(cpue~ln.pop.density + year +(1|lakeID) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|lakeID))




mod.caughtBy.lmb.pe<-glmmTMB(cpue~ln.pop.density + year +(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb.pe<-glmmTMB(cpue~ln.pop.density +  year +(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb.pe<-glmmTMB(cpue~ln.pop.density + year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb.pe<-glmmTMB(cpue~ln.pop.density + year+(1|lakeID)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb.pe<-glmmTMB(cpue~ln.pop.density + year+(1|caughtBy)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))
mod.lakeID.caughtBy.date.lmb.pe<-glmmTMB(cpue~ln.pop.density +year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.pop.density+ sc.doy + sc.doy2+year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb.pe, mod.lakeID.lmb.pe, mod.caughtBy.lmb.pe, mod.date.lmb.pe, mod.lakeID.caughtBy.lmb.pe, mod.lakeID.date.lmb.pe, mod.caughtBy.date.lmb.pe, mod.lakeID.caughtBy.date.lmb.pe )

sim.resid<-simulateResiduals(mod.caughtBy.date.lmb.pe)
plot(sim.resid)

mod.fs.pe<-mod.caughtBy.date.lmb.pe
```

Interesting; caughtBy and date random effects are best fits; does not include wbic!

```{r}
summary(mod.fs.pe)
performance::r2(mod.fs.pe)
```
higher, but not incredible r2. 

```{r}
fishscapes$mod.pred<-predict(mod.fs.pe, type="response")

ggplot(fishscapes)+
  geom_point(aes(x=pop.density, y=cpue))+
  geom_point(aes(x=pop.density, y=mod.pred), color="red")+
  theme_bw()
```
Repeat, but with ef cpe

```{r}
ggplot(fishscapes)+
  geom_point(aes(x=ef.cpe, y=cpue))+
  theme_bw()


ggplot(fishscapes)+
  geom_point(aes(x=ln.ef.cpe, y=ln.cpue))

```

Fewer months than dnr data; could still use month or day of year

instead of date random effect and month as a fixed effect, adding day of year as quadratic fixed effect.
date will still be tested as a random effect in some models

Moving sc.doy out of conditional model, but keeping it in zero inflated model. (problems with convergence, consistently no effect in conditional model)
```{r}

mod.null.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe  + year, 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year)

mod.lakeID.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year +(1|lakeID) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID))
# convergence problem
mod.caughtBy.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +  year +(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +  year +(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +year+(1|lakeID)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe +year+(1|caughtBy)+(1|date) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe + sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))


mod.lakeID.caughtBy.date.lmb.ef.cpe<-glmmTMB(cpue~ln.ef.cpe + year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes, family=glmmTMB::lognormal(link="log"),
               ziformula=~ln.ef.cpe+ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb.ef.cpe, mod.lakeID.lmb.ef.cpe, mod.caughtBy.lmb.ef.cpe, mod.date.lmb.ef.cpe, mod.lakeID.caughtBy.lmb.ef.cpe, mod.lakeID.date.lmb.ef.cpe, mod.caughtBy.date.lmb.ef.cpe, mod.lakeID.caughtBy.date.lmb.ef.cpe )

sim.resid<-simulateResiduals(mod.lakeID.caughtBy.date.lmb.ef.cpe)
plot(sim.resid)

mod.fs.ef.cpe<-mod.lakeID.caughtBy.date.lmb.ef.cpe
```


```{r}
summary(mod.fs.ef.cpe)
performance::r2(mod.fs.ef.cpe)

performance::r2_zeroinflated(mod.fs.ef.cpe)
```
ef.cpe not a significant predictor. (replaced by wbic?)

looking at predictions (deterministic--no error term) for catch rates. have to model separately zero and non-zero
```{r}
fishscapes$mod.pred<-predict(mod.fs.ef.cpe, type="response")

fishscapes$zero.pred<-predict(mod.fs.ef.cpe, type="zprob")
fishscapes$probCatchFish<-1-fishscapes$zero.pred

fishscapes$caughtFishSim<-rep(NA)


for(i in 1:nrow(fishscapes)){
fishscapes$caughtFishSim[i]<-sample(c(0,1), 1, prob=c(fishscapes$zero.pred[i], fishscapes$probCatchFish[i]))
}

fs.zeros<-filter(fishscapes, caughtFishSim==0)
fs.ones<-filter(fishscapes, caughtFishSim==1)

fs.ones$pred.cpue<-predict(mod.fs.ef.cpe, newdata=fs.ones, type="response")
fs.zeros$pred.cpue<-rep(0)

fs.pred<-rbind.data.frame(fs.ones, fs.zeros)


ggplot(fs.pred)+
  geom_point(aes(x=ef.cpe, y=cpue))+
  geom_point(aes(x=ef.cpe, y=pred.cpue), color="red", alpha=0.5)+
  theme_bw()

ggplot(fs.pred)+
  geom_histogram(aes(cpue), color="gray")+
  geom_histogram(aes(pred.cpue), fill="red", alpha=0.5)

ggplot(fs.pred)+
  geom_point(aes(x=cpue, y=pred.cpue))+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  theme_bw()
```

left off here: for(i in 1:nrow(fishscapes)){
fishscapes$caughtFish[i]<-sample(c(0,1), 1, prob=c(fishscapes$zero.pred[i], fishscapes$probCatchFish[i]))
}
Looking at random effects: 
lakeID has basically no effect on zero probability
```{r}
rand.cpue<-ranef(mod.fs.ef.cpe, condVar=T)
rand.zero<-ranef(mod.fs.ef.cpe, condVar=T)

hist(rand.zero$zi$date$`(Intercept)`)
# is there a pattern in date effect?

dates.zero<-rand.zero$zi$date
dates.zero$date<-ymd(rownames(dates.zero))

dates.zero$doy<-yday(dates.zero$date)
dates.zero$year<-year(dates.zero$date)

ggplot(dates.zero)+
  geom_point(aes(x=doy, y=`(Intercept)`, color=as.factor(year)))+
  theme_bw()

caught
```
No, not really. This suggests to me that there could have been differences in weather, temperature, etc influencing catchability each day. Those last few days are around zero, maybe because there was less variation in other variables at the end of the 2019 season. (less overlap of anglers, none of dates, potentially none of lakes)



More stuff interrogating model: predictions and r2 without angler id, full fishscapes dataset without population estimates or electrofishign cpe (didn't work well--residuals were crazy. Even if it doesn't have a significant effect, having some metric of fish population is important)
--------------------------------------------------------------------------------
Look at the next best fitting model that does not include angler effects

```{r}
summary(mod.date.lmb.ef.cpe)
performance::r2(mod.date.lmb.ef.cpe)
```
```{r}
fishscapes.ef.cpe$pred.date<-predict(mod.date.lmb.ef.cpe, type="response")
ggplot(fishscapes.ef.cpe)+
  geom_point(aes(x=ln.ef.cpe, y=anCPUE))+
  geom_point(aes(x=ln.ef.cpe, y=pred.date), color="red")
```









What if I fit the full dataset, avoiding population density entirely? 

one lake doesn't have a WBIC, so using lakeID instead

```{r}
fishscapes.full<-fishscapes.full%>%
  mutate(year=as.factor(year),
         cpue=anCPUE,
         wbic=as.factor(WBIC),
         lakeID=as.factor(lakeID),
         date=as.factor(date))
  

mod.null.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2 + year, 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year)

mod.lakeID.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|lakeID) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID))

mod.caughtBy.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|caughtBy))

mod.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+ year +(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|date))

mod.lakeID.caughtBy.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|caughtBy), 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|caughtBy) )

mod.lakeID.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date))

mod.caughtBy.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|caughtBy)+(1|date) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2+year+(1|caughtBy)+(1|date))
mod.lakeID.caughtBy.date.lmb<-glmmTMB(cpue~ sc.doy + sc.doy2+year+(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~ sc.doy + sc.doy2 +year+(1|lakeID)+(1|date)+(1|caughtBy) )

AIC(mod.null.lmb, mod.lakeID.lmb, mod.caughtBy.lmb, mod.date.lmb, mod.lakeID.caughtBy.lmb, mod.lakeID.date.lmb, mod.caughtBy.date.lmb, mod.lakeID.caughtBy.date.lmb )


mod.fs.full<-mod.lakeID.caughtBy.date.lmb

mod.resid<-simulateResiduals(mod.fs.full, plot=T)
plot(mod.resid, form=fishscapes.full$sc.doy)
plot(mod.resid, form=fishscapes.full$sc.doy2)
plot(mod.resid, form=fishscapes.full$year)
plot(mod.resid, form=fishscapes.full$lakeID)
plot(mod.resid, form=fishscapes.full$date)
plot(mod.resid, form=fishscapes.full$caughtBy)

```

```{r}
summary(mod.fs.full)
performance::r2(mod.fs.full)
```










only random effects

```{r}
mod.random<-glmmTMB(cpue~(1|lakeID)+(1|date)+(1|caughtBy) , 
                  data=fishscapes.full, family=glmmTMB::lognormal(link="log"),
               ziformula=~(1|lakeID)+(1|date)+(1|caughtBy) )

simulateResiduals(mod.random, plot=T)
```
some metric of fish abundance is probably necessary. without it, I get these super weird residuals


fishscapes full

```{r}
caught.prop<-fishscapes.full%>%
  mutate(totalFish=sum(nCaught))%>%
  group_by(caughtBy)%>%
  summarize(nFish=sum(nCaught),
            totalFish=unique(totalFish))%>%
  ungroup()%>%
  mutate(propCatch=nFish/totalFish,
         propAnglers=1/length(unique(fishscapes.full$caughtBy)))%>%
  arrange(propCatch)%>%
  mutate(cumPropCatch=cumsum(propCatch),
         cumPropAnglers=cumsum(propAnglers))

order<-caught.prop$caughtBy

caught.prop$caughtBy<-factor(caught.prop$caughtBy, levels=order)

ggplot(caught.prop)+
  geom_bar(aes(x=caughtBy, y=propCatch), stat="identity")
```

Lorenz plot

```{r}
ggplot(caught.prop)+
  geom_line(aes(x=cumPropAnglers, y=cumPropCatch))+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  geom_abline(slope=-1, intercept=1, linetype="dashed")+
  theme_bw()
```

Neat, but not accounting for differences in effort. Do that one comparing between trip and between angler inequaliity

then look at differences in fish size--associated with catching power intercept? 

catch power as a random walk?

Between angler inequality: cumulative proportion of catch by cumulative proportion of effort for each angler's contribution to the season total

Between trip inequality: cumulative proportion of catch by the cumulative proportion of effort that each trip contributes to the season total

```{r}
between.angler<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort))%>%
  group_by(caughtBy)%>%
  summarize(angler.fish=sum(nCaught),
            angler.effort=sum(effort),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=angler.fish/fish.total,
         prop.effort=angler.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))
  

#  I think this comparison might be misleading--aggregates of anglers vs. individual trips. Aggregate trips by sample id instead
between.trip<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort),
         trip=paste(sampleID, angler_num, sep="_"),
         trip.fish=nCaught,
         trip.effort=effort,
         prop.fish=trip.fish/fish.total,
         prop.effort=trip.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))

between.lake<-fishscapes.full%>%
  mutate(fish.total=sum(nCaught),
         effort.total=sum(effort))%>%
  group_by(lakeID)%>%
  summarize(lake.fish=sum(nCaught),
            lake.effort=sum(effort),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=lake.fish/fish.total,
         prop.effort=lake.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))


ggplot()+
  geom_line(data=between.angler, aes(y=cum.prop.fish, x=cum.prop.effort), color="blue")+
  geom_line(data=between.trip, aes(y=cum.prop.fish, x=cum.prop.effort), color="red")+
  geom_line(data=between.lake, aes(y=cum.prop.fish, x=cum.prop.effort), color="green")+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  theme_bw()
```

Much more inequality among trips than among anglers, but not comparing same 'sample size'--way more trip dates than unique anglers

This is not unexpected, "there is inequality within, and overlap between, the trip-to-trip success of each angler" Lambert and Aronson 1993; Yao 1999

other catch inequality papers: Mosindy and Duffy 2007 (musky), Van Poorten and Post 2005 (rainbow trout)


can I compare to angler diary data? Opportunity to show changes in Gini coefficient over time if I can have access to more years. Split by species

```{r}
codes<-read_csv(here::here("data","coding.csv"))%>%
  select(code, `Target Species`, category)%>%
  rename("TargetSpecies"=code,
         "TargetSpeciesName"=`Target Species`, 
         "TargetSpeciesCat"=category)
`%!in%`<-Negate(`%in%`)

diary<-read_csv(here::here("data","angler.diary.data.csv"))%>%
    arrange(SurveyID)%>%
  mutate(daysMonth=ifelse(Month%in%c(9,4,6,11), 30, 
                          ifelse(Month==2, 28, 31)),
         date_month=as.numeric(month(mdy(Date))),
         outsideMonth=ifelse(FishedYN==1 & date_month!=Month,1,0),
         Year=ifelse(Month%in%c(4,5,6,7,8,9,10,11,12), 2021, 2022))%>%
  # remove entries where participants went fishing outside the sampled calendar month
  filter(outsideMonth==0)%>%
  filter(Mode==1)%>%
  filter(SurveyID!="999999")%>%
  filter(SurveyID%!in%c(1:10))%>%
  left_join(codes, by="TargetSpecies")%>%
  filter(County!="99")

# Do I care if they're representative? I don't think so, but worth checking to see if it changes the results to leave out emailed responses
fished<-diary%>%
  filter(FishedYN==1)

# let's pivot thisl onger to make it easier to work with

fished.long.caught<-fished%>%
  dplyr::select(SurveyID, Date, Month, Year, WaterFished, County, Hours, TargetSpeciesName, ends_with("Caught"))%>%
  pivot_longer(cols=c(BluegillNumCaught:OtherNumCaught), names_to="species",values_to="numCaught")%>%
  mutate(species=str_replace(species, "NumCaught", ""),
         cpue=numCaught/Hours)

# lorenz plot--just LMB for now, and only angler targeting them

between.angler.diary<-fished.long.caught%>%
  filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours))%>%
  group_by(SurveyID)%>%
  summarize(angler.fish=sum(numCaught),
            angler.effort=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=angler.fish/fish.total,
         prop.effort=angler.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))


between.trip.diary<-fished.long.caught%>%
  filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours),
         tripID=paste(SurveyID, Date, WaterFished, sep="_"))%>%
  group_by(tripID)%>%
  summarize(trip.fish=sum(numCaught),
            trip.effort=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=trip.fish/fish.total,
         prop.effort=trip.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))

# imperfect; includes duplicate lakes/rivers within counties
between.water.diary<-fished.long.caught%>%
  filter(species=="LGBass" & TargetSpeciesName=="Largemouth Bass")%>%
  mutate(fish.total=sum(numCaught),
         effort.total=sum(Hours),
         waterID=paste(County, WaterFished, sep="_"))%>%
  group_by(waterID)%>%
  summarize(water.fish=sum(numCaught),
            water.effort=sum(Hours),
            fish.total=unique(fish.total),
            effort.total=unique(effort.total))%>%
  ungroup()%>%
  mutate(prop.fish=water.fish/fish.total,
         prop.effort=water.effort/effort.total)%>%
  arrange(prop.fish)%>%
  mutate(cum.prop.fish=cumsum(prop.fish),
         cum.prop.effort=cumsum(prop.effort))



ggplot()+
  geom_line(data=between.angler.diary, aes(x=cum.prop.effort, y=cum.prop.fish), color="blue")+
  geom_line(data=between.trip.diary, aes(x=cum.prop.effort, y=cum.prop.fish), color="red")+
  geom_line(data=between.water.diary, aes(x=cum.prop.effort, y=cum.prop.fish), color="green")+
  geom_abline(slope=1, intercept=0, linetype="dashed")+
  theme_bw()
```

  

Next step:
- filter to lakes with biological survey data--fit catch curve with random effects? See how much data is actually left. 