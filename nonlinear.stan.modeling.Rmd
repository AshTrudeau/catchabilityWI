---
title: "nonlinear stan modeling"
output: html_document
date: "2024-04-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, here, lubridate, lme4, rstan, shinystan, truncnorm)
```

Fitting nonlinear models in Stan with fake data. 

This is a helpful tutorial using fishery data https://www.weirdfishes.blog/blog/fitting-bayesian-models-with-stan-and-r/ 


```{r}
catch.fun.err<-function(effort, q, popDensity, beta, error){
  catch=(effort*q*popDensity^beta)*error
  return(catch)
}

catch.fun<-function(effort, q, popDensity, beta){
  catch=(effort*q*popDensity^beta)
  return(catch)
}


# q as a truncated (at zero) normal? 

fake.df<-data.frame(popDensity=rlnorm(100, meanlog=2, sdlog=0.2),
                    effort=rlnorm(100, meanlog=1.25, sdlog=0.25),
                    q=rtruncnorm(100, a=0, b=Inf, mean=0.5, sd=1),
                    beta=rlnorm(100, meanlog=-1, 0.3),
                    error=rlnorm(100, meanlog=0, sdlog=0.3))

fake.df$catch<-floor(catch.fun.err(fake.df$effort, fake.df$q, fake.df$popDensity, fake.df$beta, fake.df$error))

fake.data<-list(N=nrow(fake.df),
                effort=fake.df$effort,
                lmbCatch=fake.df$catch,
                popDensity=fake.df$popDensity)
```
estimate q and beta
```{r}
fake_fit<-stan(file="fake.nonlinear.nb.stan",
                 data=fake.data,
                 chains=4,
                 warmup=1000,
                 iter=2000,
                 cores=4,
                 refresh=0)

print(fake_fit, pars=c("q","beta","phi", "lp__"), probs=c(.025,.5,.975))

traceplot(fake_fit, pars=c("q","beta","phi","lp__"), inc_warmup=FALSE, nrow=2)

```

Now try to add random effects. I'll make this more trivial by just repeating rows of the fake data
I want estimate a grand mean q and anglerID-specific q coefficients

left off here trying to parse example https://mc-stan.org/docs/stan-users-guide/regression.html#hierarchical-regression 
```{r}

fake.df<-data.frame(popDensity=rlnorm(100, meanlog=2, sdlog=0.2),
                    effort=rlnorm(100, meanlog=1.25, sdlog=0.25),
                    #q=rtruncnorm(100, a=0, b=Inf, mean=0.5, sd=1),
                    q=rlnorm(100, -0.5, 0.5),
                    beta=rlnorm(100, meanlog=-1, 0.3),
                    error=rlnorm(100, meanlog=0, sdlog=0.3))

fake.df$catch<-floor(catch.fun.err(fake.df$effort, fake.df$q, fake.df$popDensity, fake.df$beta, fake.df$error))

fake.df.rep<-fake.df%>%
  mutate(anglerID=seq(1:nrow(fake.df)))%>%
  group_by(anglerID)%>%
  slice(rep(1:n(), each=5))

fake.data.hier<-list(A=max(fake.df.rep$anglerID),
                     N=nrow(fake.df.rep),
                     AA=fake.df.rep$anglerID,
                     lmbCatch=fake.df.rep$catch,
                     effort=fake.df.rep$effort,
                     popDensity=fake.df.rep$popDensity
                     )

fake_fit_hier<-stan(file="fake.hierarchical.nonlinear.nb.stan",
                 data=fake.data.hier,
                 control=list(stepsize=1),
                 chains=4,
                 warmup=1000,
                 iter=2000,
                 cores=4,
                 refresh=0)

# print(fake_fit, pars=c("q","beta","phi", "lp__"), probs=c(.025,.5,.975))
# 
# traceplot(fake_fit, pars=c("q","beta","phi","lp__"), inc_warmup=FALSE, nrow=2)

launch_shinystan(fake_fit_hier)

```

fake.df<-data.frame(popDensity=rlnorm(100, meanlog=2, sdlog=0.2),
                    effort=rlnorm(100, meanlog=1.25, sdlog=0.25),
                    #q=rtruncnorm(100, a=0, b=Inf, mean=0.5, sd=1),
                    q=rlnorm(100, -0.5, 0.5),
                    beta=rlnorm(100, meanlog=-1, 0.3),
                    error=rlnorm(100, meanlog=0, sdlog=0.3))


Useful example in answers here of nonlinear hierarchical model https://stackoverflow.com/questions/50749414/developing-hierarchical-version-of-nonlinear-growth-curve-model-in-stan 

fake data for more heirarchical levels, making fake data closer to the real data I'm going to analyze

```{r}
set.seed(395)
catch.fun.err<-function(effort, q_mu, q_d, q_a, q_l, popDensity, beta, error){
  catch=(effort*(q_mu+q_d+q_a+q_l)*popDensity^beta)*error
  return(catch)
}

# 90 unique dates
D<-90
# 20 unique anglers
A<-20
# 10 unique lakes
L<-10

q_d<-rlnorm(D, -1, 0.5)
q_a<-rlnorm(A, -2, 0.2)
q_l<-rlnorm(L, -2, 0.01)

q_mu<-0.2

popDensity<-rlnorm(L, meanlog=2, sdlog=0.2)
beta<-0.25

# D, A, and L indexes and their q values
dates<-data.frame(D=seq(1:D), q_d=q_d)
anglers<-data.frame(A=seq(1:A), q_a=q_a)
lakes<-data.frame(L=seq(1:L), q_l=q_l, popDensity=popDensity)

# sample randomly with replacement from anglers and lakes for each date. then left_join approprate q values by A, D, and L selection

lakeSamples<-sample(lakes$L, 180, replace=TRUE)
anglerSamples<-sample(anglers$A, 540, replace=TRUE)


# 2 lakes visited each day, three anglers at each lake
fake.df.hier<-data.frame(D=rep(dates$D, each=6),
                         L=rep(lakeSamples, each=3),
                         A=anglerSamples)%>%
  left_join(dates, by="D")%>%
  left_join(anglers, by="A")%>%
  left_join(lakes, by="L")%>%
  mutate(beta=rep(0.25),
         q_mu=rep(0.2),
         effort=rlnorm(540, meanlog=1.25, sdlog=0.25),
         error=rlnorm(540, meanlog=0, sdlog=0.3),
         lmbCatch=floor(catch.fun.err(effort, q_mu, q_d, q_a, q_l, popDensity, beta, error)))

fake.data.hier<-list(N=nrow(fake.df.hier),
                     D=D,
                     L=L,
                     A=A,
                     DD=fake.df.hier$D,
                     LL=fake.df.hier$L,
                     AA=fake.df.hier$A,
                     effort=fake.df.hier$effort,
                     popDensity=fake.df.hier$popDensity,
                     lmbCatch=fake.df.hier$lmbCatch)


fake_fit_hier<-stan(file="fake.hierarchical.nonlinear.nb.stan",
                 data=fake.data.hier,
                 control=list(stepsize=0.1, max_treedepth=15),
                 chains=4,
                 warmup=1000,
                 iter=2000,
                 cores=4,
                 refresh=0)

launch_shinystan(fake_fit_hier)

pairs(fake_fit_hier, pars=c("mu_q_a","mu_q_d","mu_q_l","beta", "phi","sigma_q_a","sigma_q_d", "sigma_q_l"))
```

this fake data has fewer zeroes than the real data will, but at least it has them.

Trying non-centered parameterization https://mc-stan.org/docs/2_18/stan-users-guide/reparameterization-section.html
useful resource https://betanalpha.github.io/assets/case_studies/hierarchical_modeling.html 

this post gets into non-centeredc lognormal https://discourse.mc-stan.org/t/centred-vs-non-centred-parametrisation-with-lognormal-likelihood/13976/13 

```{r}
fake_fit_noncentered_hier<-stan(file="noncentered.hierarchical.nonlinear.nb.stan",
                 data=fake.data.hier,
                 control=list(stepsize=0.1, max_treedepth=15),
                 chains=1,
                 warmup=1000,
                 iter=2000,
                 cores=1,
                 refresh=0)

```

